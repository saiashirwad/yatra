This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-15T12:38:54.905Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  columns.ts
  index.ts
  table.ts
  utils.ts
.gitignore
biome.json
bun.lock
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: src/columns.ts
================
type Nullable = { readonly __nullable: true }
type Default<T> = { readonly default: T }
type MinLength<T extends number> = { readonly minLength: T }
type MaxLength<T extends number> = { readonly maxLength: T }
type Format<T extends string> = { readonly format: T }
type Enum<T extends unknown[]> = { readonly enum: T }
type Min<T extends number> = { readonly min: T }
type Max<T extends number> = { readonly max: T }
type Integer = { readonly integer: true }
type Unique = { readonly unique: true }
type PrimaryKey = { readonly primaryKey: true }
type References<T extends string> = {
	readonly references: { table: T; column: string }
}
type AutoIncrement = { readonly autoIncrement: true }
type Generated<T extends string> = {
	readonly generated: { expression: T }
}
type Comment<T extends string> = { readonly comment: T }
type Precision<T extends number> = { readonly precision: T }
type Scale<T extends number> = { readonly scale: T }
type Check<T extends string> = { readonly check: T }
type Index = { readonly index: true }
type SearchIndexed = { readonly searchIndexed: true }

export function extend<This, Brand>(
	instance: This,
	propertyName: string,
	propertyValue: unknown,
): This & Brand {
	const newInstance = Object.create(Object.getPrototypeOf(instance))

	Object.assign(newInstance, instance)
	;(newInstance as any)[propertyName] = propertyValue

	return newInstance as This & Brand
}

export type ColumnType =
	| "string"
	| "number"
	| "boolean"
	| "date"
	| "literal"
	| "json"
	| "jsonb"
	| "uuid"
	| "array"
	| "binary"
	| "text"
	| "bigint"
	| "timestamp"
	| "time"
	| "inet"
	| "cidr"
	| "macaddr"
	| "decimal"
	| "enum"

export type ColumnParams = {
	T: ColumnType
	DataType: any
}

export class Column<
	Params extends ColumnParams,
	T = Params["T"],
	DataType = Params["DataType"],
> {
	readonly type: T

	constructor(type: T) {
		this.type = type
	}

	nullable(): this & Nullable {
		return extend<this, Nullable>(this, "__nullable", true)
	}

	default<const V extends DataType>(value: V): this & Default<V> {
		return extend<this, Default<V>>(this, "default", value)
	}

	unique(): this & Unique {
		return extend<this, Unique>(this, "unique", true)
	}

	primaryKey(): this & PrimaryKey {
		return extend<this, PrimaryKey>(this, "primaryKey", true)
	}

	references<T extends string>(
		table: T,
		column: string,
	): this & References<T> {
		return extend<this, References<T>>(this, "references", {
			table,
			column,
		})
	}

	autoIncrement(): this & AutoIncrement {
		return extend<this, AutoIncrement>(this, "autoIncrement", true)
	}

	generated<T extends string>(expression: T): this & Generated<T> {
		return extend<this, Generated<T>>(this, "generated", {
			expression,
		})
	}

	comment<T extends string>(text: T): this & Comment<T> {
		return extend<this, Comment<T>>(this, "comment", text)
	}

	check<T extends string>(expression: T): this & Check<T> {
		return extend<this, Check<T>>(this, "check", expression)
	}

	index(): this & Index {
		return extend<this, Index>(this, "index", true)
	}

	searchIndexed(): this & SearchIndexed {
		return extend<this, SearchIndexed>(this, "searchIndexed", true)
	}

	getConfig(): Record<string, unknown> {
		const config: Record<string, unknown> = { type: this.type }

		for (const key in this) {
			if (
				key !== "type" &&
				!key.startsWith("_") &&
				typeof (this as any)[key] !== "function"
			) {
				config[key] = (this as any)[key]
			}
		}

		return config
	}
}

export type StringFormat =
	| "uuid"
	| "json"
	| "email"
	| "url"
	| "cuid"
	| "ip"
	| "datetime"

export class StringColumn<
	Params extends ColumnParams = { T: "string"; DataType: string },
> extends Column<Params> {
	constructor() {
		super("string")
	}

	minLength<T extends number>(length: T): this & MinLength<T> {
		return extend<this, MinLength<T>>(this, "minLength", length)
	}

	maxLength<T extends number>(length: T): this & MaxLength<T> {
		return extend<this, MaxLength<T>>(this, "maxLength", length)
	}

	format<T extends StringFormat>(formatType: T): this & Format<T> {
		return extend<this, Format<T>>(this, "format", formatType)
	}

	enum<T extends unknown[]>(values: T): this & Enum<T> {
		return extend<this, Enum<T>>(this, "enum", values)
	}
}

export class NumberColumn extends Column<{
	T: "number"
	DataType: number
}> {
	constructor() {
		super("number")
	}

	min<T extends number>(value: T): this & Min<T> {
		return extend<this, Min<T>>(this, "min", value)
	}

	max<T extends number>(value: T): this & Max<T> {
		return extend<this, Max<T>>(this, "max", value)
	}

	integer(): this & Integer {
		return extend<this, Integer>(this, "integer", true)
	}

	precision<T extends number>(value: T): this & Precision<T> {
		return extend<this, Precision<T>>(this, "precision", value)
	}

	scale<T extends number>(value: T): this & Scale<T> {
		return extend<this, Scale<T>>(this, "scale", value)
	}
}

export class DecimalColumn extends Column<{
	T: "decimal"
	DataType: string | number
}> {
	constructor() {
		super("decimal")
	}

	precision<T extends number>(value: T): this & Precision<T> {
		return extend<this, Precision<T>>(this, "precision", value)
	}

	scale<T extends number>(value: T): this & Scale<T> {
		return extend<this, Scale<T>>(this, "scale", value)
	}
}

export class BooleanColumn extends Column<{
	T: "boolean"
	DataType: boolean
}> {
	constructor() {
		super("boolean")
	}
}

export class JsonColumn extends Column<{
	T: "json"
	DataType: object | string
}> {
	constructor() {
		super("json")
	}
}

export class JsonbColumn extends Column<{
	T: "jsonb"
	DataType: object | string
}> {
	constructor() {
		super("jsonb")
	}
}

export class UuidColumn extends Column<{
	T: "uuid"
	DataType: string
}> {
	constructor() {
		super("uuid")
	}
}

export class TextColumn extends Column<{
	T: "text"
	DataType: string
}> {
	constructor() {
		super("text")
	}
}

export class BigIntColumn extends Column<{
	T: "bigint"
	DataType: bigint | number
}> {
	constructor() {
		super("bigint")
	}
}

export class TimestampColumn extends Column<{
	T: "timestamp"
	DataType: Date | string | number
}> {
	constructor(private withTimezone: boolean = true) {
		super("timestamp")
	}

	getConfig(): Record<string, unknown> {
		const config = super.getConfig()
		config.withTimezone = this.withTimezone
		return config
	}

	withoutTimezone(): this {
		const clone = Object.create(Object.getPrototypeOf(this)) as this
		Object.assign(clone, this)
		clone.withTimezone = false
		return clone
	}
}

export class TimeColumn extends Column<{
	T: "time"
	DataType: string | Date
}> {
	constructor(private withTz: boolean = false) {
		super("time")
	}

	getConfig(): Record<string, unknown> {
		const config = super.getConfig()
		config.withTimezone = this.withTimezone
		return config
	}

	withTimezone(): this {
		const clone = Object.create(Object.getPrototypeOf(this)) as this
		Object.assign(clone, this)
		clone.withTz = true
		return clone
	}
}

export class BinaryColumn extends Column<{
	T: "binary"
	DataType: Uint8Array | Buffer | string
}> {
	constructor() {
		super("binary")
	}
}

export class ArrayColumn<
	ItemType extends Column<any, any>,
> extends Column<{
	T: "array"
	DataType: Array<GetDataType<ItemType>>
}> {
	private itemType: ItemType

	constructor(itemType: ItemType) {
		super("array")
		this.itemType = itemType
	}

	getConfig(): Record<string, unknown> {
		const config = super.getConfig()
		config.items = this.itemType.getConfig()
		return config
	}
}

export class EnumColumn<T extends string[]> extends Column<{
	T: "enum"
	DataType: T[number]
}> {
	constructor(private values: T) {
		super("enum")
	}

	getConfig(): Record<string, unknown> {
		const config = super.getConfig()
		config.values = this.values
		return config
	}
}

export type DateDataType = Date | number

export class DateColumn extends Column<{
	T: "date"
	DataType: DateDataType
}> {
	constructor() {
		super("date")
	}
}

export type LiteralFieldType = string | number | boolean

export class LiteralColumn<
	T extends LiteralFieldType,
> extends Column<{
	T: "literal"
	DataType: T
}> {
	readonly literalValue: T

	constructor(value: T) {
		super("literal")
		this.literalValue = value
	}
}

export function string(): StringColumn {
	return new StringColumn()
}

export function number(): NumberColumn {
	return new NumberColumn()
}

export function date(): DateColumn {
	return new DateColumn()
}

export function literal<T extends LiteralFieldType>(
	value: T,
): LiteralColumn<T> {
	return new LiteralColumn(value)
}

export function boolean(): BooleanColumn {
	return new BooleanColumn()
}

export function json(): JsonColumn {
	return new JsonColumn()
}

export function jsonb(): JsonbColumn {
	return new JsonbColumn()
}

export function uuid(): UuidColumn {
	return new UuidColumn()
}

export function text(): TextColumn {
	return new TextColumn()
}

export function bigint(): BigIntColumn {
	return new BigIntColumn()
}

export function timestamp(
	withTimezone: boolean = true,
): TimestampColumn {
	return new TimestampColumn(withTimezone)
}

export function time(withTimezone: boolean = false): TimeColumn {
	return new TimeColumn(withTimezone)
}

export function binary(): BinaryColumn {
	return new BinaryColumn()
}

export function decimal(): DecimalColumn {
	return new DecimalColumn()
}

export function array<T extends Column<any, any>>(
	itemType: T,
): ArrayColumn<T> {
	return new ArrayColumn(itemType)
}

export function _enum<T extends string[]>(
	values: [...T],
): EnumColumn<T> {
	return new EnumColumn(values)
}

export type IsPrimaryKey<T> = T extends PrimaryKey ? true : false
export type IsUnique<T> = T extends Unique ? true : false
export type GetReferences<T> = T extends References<infer Table>
	? { table: Table; column: string }
	: undefined
export type IsAutoIncrement<T> = T extends AutoIncrement
	? true
	: false
export type GetGenerated<T> = T extends Generated<infer Expr>
	? Expr
	: undefined
export type GetComment<T> = T extends Comment<infer Text>
	? Text
	: undefined
export type GetPrecision<T> = T extends Precision<infer P>
	? P
	: undefined
export type GetScale<T> = T extends Scale<infer S> ? S : undefined

export type GetDataType<T> = T extends Column<infer Params>
	? Params extends ColumnParams
		? Params["DataType"]
		: never
	: never
export type IsNullable<T> = T extends Nullable ? true : false
export type GetDefault<T> = T extends Default<infer V> ? V : undefined
export type GetMinLength<T> = T extends MinLength<infer V>
	? V
	: undefined
export type GetMaxLength<T> = T extends MaxLength<infer V>
	? V
	: undefined

export type GetColumnType<T> = T extends StringColumn
	? string
	: T extends NumberColumn
		? number
		: T extends BooleanColumn
			? boolean
			: T extends DateColumn
				? Date
				: T extends LiteralColumn<infer V>
					? V
					: T extends JsonColumn | JsonbColumn
						? object | string
						: T extends UuidColumn
							? string
							: T extends ArrayColumn<infer ItemType>
								? Array<GetDataType<ItemType>>
								: T extends TextColumn
									? string
									: T extends BigIntColumn
										? bigint | number
										: T extends TimestampColumn
											? Date | string | number
											: T extends TimeColumn
												? string | Date
												: T extends BinaryColumn
													? Uint8Array | Buffer | string
													: T extends DecimalColumn
														? string | number
														: T extends EnumColumn<infer Values>
															? Values[number]
															: never

================
File: src/index.ts
================
import { _enum, array, Column, string, uuid } from "./columns"
import { manyToOne, oneToMany, Table } from "./table"

================
File: src/table.ts
================
import {
	_enum,
	array,
	Column,
	number,
	string,
	uuid,
	type GetColumnType,
	type IsNullable,
} from "./columns"
import { type Clean, type Constructor } from "./utils"

export function member<
	Co extends Constructor,
	Instance extends InstanceType<Co>,
	K extends keyof Instance,
>(c: Co, key: K): Instance[K] {
	return new c()[key]
}

type TableConstructor<F> = new (...args: any[]) => { fields: F }

type ManyToOneRelation<Ref, VirtualField, ForeignKey> = {
	kind: "many-to-one"
	ref: Ref
	virtualField: VirtualField
	foreignKey: ForeignKey
}

type OneToManyRelation<Ref> = {
	kind: "one-to-many"
	ref: Ref
}

type OneToOneRelation<Ref, VirtualField, ForeignKey> = {
	kind: "one-to-one"
	ref: Ref
	virtualField: VirtualField
	foreignKey: ForeignKey
}

export type Relation =
	| ManyToOneRelation<any, any, any>
	| OneToManyRelation<any>
	| OneToOneRelation<any, any, any>

class ManyToOneBuilder<
	F extends Record<string, Column<any, any>>,
	Ref extends () => TableConstructor<any>,
> {
	private virtualField?: keyof F
	private foreignKey?: keyof InstanceType<ReturnType<Ref>>["fields"]

	constructor(
		private fields: F,
		private ref: Ref,
	) {}

	using<VF extends keyof F>(virtualField: VF) {
		this.virtualField = virtualField
		return this
	}

	references<
		FK extends keyof InstanceType<ReturnType<Ref>>["fields"],
	>(foreignKey: FK) {
		this.foreignKey = foreignKey
		return this
	}

	build(): ManyToOneRelation<
		Ref,
		keyof F,
		keyof InstanceType<ReturnType<Ref>>["fields"]
	> {
		if (!this.virtualField || !this.foreignKey) {
			throw new Error(
				"ManyToOne relation requires both virtualField and foreignKey",
			)
		}

		return {
			kind: "many-to-one",
			ref: this.ref,
			virtualField: this.virtualField,
			foreignKey: this.foreignKey,
		}
	}
}

class OneToManyBuilder<Ref extends () => any> {
	constructor(private ref: Ref) {}

	build(): OneToManyRelation<Ref> {
		return {
			kind: "one-to-many",
			ref: this.ref,
		}
	}
}

class OneToOneBuilder<
	F extends Record<string, Column<any, any>>,
	Ref extends () => TableConstructor<any>,
> {
	private virtualField?: keyof F
	private foreignKey?: keyof InstanceType<ReturnType<Ref>>["fields"]

	constructor(
		private fields: F,
		private ref: Ref,
	) {}

	using<VF extends keyof F>(virtualField: VF) {
		this.virtualField = virtualField
		return this
	}

	references<
		FK extends keyof InstanceType<ReturnType<Ref>>["fields"],
	>(foreignKey: FK) {
		this.foreignKey = foreignKey
		return this
	}

	build(): OneToOneRelation<
		Ref,
		keyof F,
		keyof InstanceType<ReturnType<Ref>>["fields"]
	> {
		if (!this.virtualField || !this.foreignKey) {
			throw new Error(
				"OneToOne relation requires both virtualField and foreignKey",
			)
		}

		return {
			kind: "one-to-one",
			ref: this.ref,
			virtualField: this.virtualField,
			foreignKey: this.foreignKey,
		}
	}
}

export function manyToOne<
	F extends Record<string, Column<any, any>>,
	Ref extends () => TableConstructor<any>,
>(t: F, ref: Ref): ManyToOneBuilder<F, Ref> {
	return new ManyToOneBuilder(t, ref)
}

export function oneToMany<
	F extends Record<string, Column<any, any>>,
	Ref extends () => any,
>(t: F, ref: Ref): OneToManyBuilder<Ref> {
	return new OneToManyBuilder(ref)
}

export function oneToOne<
	F extends Record<string, Column<any, any>>,
	Ref extends () => TableConstructor<any>,
>(t: F, ref: Ref): OneToOneBuilder<F, Ref> {
	return new OneToOneBuilder(t, ref)
}

type TableCallback<
	Fields extends Record<string, Column<any, any>>,
	Relations extends Record<string, Relation>,
> = (fields: Fields) => {
	relations: Relations
}

type MakeObject<
	Fields = Record<string, Column<any, any>>,
	Relations extends Record<string, Relation> = Record<string, never>,
	Nullable = {
		-readonly [k in keyof Fields as IsNullable<Fields[k]> extends true
			? k
			: never]?: GetColumnType<Fields[k]>
	},
	NonNullable = {
		-readonly [k in keyof Fields as IsNullable<
			Fields[k]
		> extends false
			? k
			: never]: GetColumnType<Fields[k]>
	},
	Rels = {
		[k in keyof Relations]?: Relations[k]["kind"] extends "one-to-one"
			?
					| InstanceType<ReturnType<Relations[k]["ref"]>>
					| MakeObject<
							InstanceType<ReturnType<Relations[k]["ref"]>>["fields"]
					  >
			: Relations[k]["kind"] extends "many-to-one" | "one-to-many"
				?
						| InstanceType<ReturnType<Relations[k]["ref"]>>[]
						| MakeObject<
								InstanceType<
									ReturnType<Relations[k]["ref"]>
								>["fields"]
						  >[]
				: never
	},
> = Clean<Nullable & NonNullable & Rels>

type TableConstructorArgs<
	Fields extends Record<string, Column<any, any>>,
	Relations extends Record<string, Relation>,
> = MakeObject<Fields, Relations>

type Table = InstanceType<ReturnType<typeof Table>>

export function Table<
	const TableName extends string,
	const Fields extends Record<string, Column<any, any>>,
	const Relations extends Record<string, Relation> = Record<
		string,
		never
	>,
>(
	tableName: TableName,
	fields: Fields,
	callback?: TableCallback<Fields, Relations>,
) {
	type TableInstance = {
		name: TableName
		fields: Fields
		relations: Relations
	} & MakeObject<Fields>

	class TableClass {
		public name: TableName = tableName
		public fields: Fields = fields
		public relations: Relations = {} as Relations

		constructor(args: MakeObject<Fields, Relations>) {
			if (callback) {
				const result = callback(fields)
				this.relations = result.relations
			}
			if (typeof args === "object") {
				for (const key in args) {
					;(this as any)[key] = (args as any)[key]
				}
			}
		}
	}
	return TableClass as unknown as {
		new (args: TableConstructorArgs<Fields, Relations>): TableInstance
		readonly isTable: true
	}
}

class Book extends Table(
	"book",
	{
		id: uuid().primaryKey(),
		authorId: string(),
		description: string().default("what"),
		price: number().nullable(),
	},
	(fields) => ({
		relations: {
			author: oneToOne(fields, () => User)
				.using("authorId")
				.references("id")
				.build(),
		},
	}),
) {}

class User extends Table(
	"user",
	{
		id: uuid().primaryKey(),
		name: string().default("no name").unique(),
		tags: array(_enum(["hi", "there"])).nullable(),
		type: _enum(["admin", "user"]),
	},
	(fields) => ({
		relations: {
			books: oneToMany(fields, () => Book).build(),
		},
	}),
) {}

const user = new User({
	type: "user",
	id: "asdf",
	name: "asdf",
	tags: [],
	books: [
		{
			description: "hi",
			id: "what",
			price: 2,
			authorId: "asdf",
		},
	],
})

console.log(user)

//const author = book.relations.author
//// @ts-ignore
//const lol = Reflect.construct(author.ref(), ["init"])
//// @ts-ignore
//console.log(lol)

================
File: src/utils.ts
================
export type Clean<T> = { [k in keyof T]: T[k] } & unknown

export type Class<O extends Record<string, unknown>> = {
	new (): InstanceType<new () => O>
}

export type Constructor<Args = any, ReturnType = any> = new (...args: Args[]) => ReturnType

export function member<
	Co extends Constructor,
	Instance extends InstanceType<Co>,
	K extends keyof Instance,
>(c: Co, key: K): Instance[K] {
	return new c()[key]
}

================
File: .gitignore
================
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

================
File: biome.json
================
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "files": {
    "ignoreUnknown": false,
    "ignore": []
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "tab"
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": false
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double",
      "lineWidth": 70,
      "semicolons": "asNeeded",
      "trailingCommas": "all"
    }
  }
}

================
File: bun.lock
================
{
  "lockfileVersion": 1,
  "workspaces": {
    "": {
      "name": "dbschema",
      "devDependencies": {
        "@biomejs/biome": "^1.9.4",
        "@types/bun": "latest",
      },
      "peerDependencies": {
        "typescript": "^5",
      },
    },
  },
  "packages": {
    "@biomejs/biome": ["@biomejs/biome@1.9.4", "", { "optionalDependencies": { "@biomejs/cli-darwin-arm64": "1.9.4", "@biomejs/cli-darwin-x64": "1.9.4", "@biomejs/cli-linux-arm64": "1.9.4", "@biomejs/cli-linux-arm64-musl": "1.9.4", "@biomejs/cli-linux-x64": "1.9.4", "@biomejs/cli-linux-x64-musl": "1.9.4", "@biomejs/cli-win32-arm64": "1.9.4", "@biomejs/cli-win32-x64": "1.9.4" }, "bin": { "biome": "bin/biome" } }, "sha512-1rkd7G70+o9KkTn5KLmDYXihGoTaIGO9PIIN2ZB7UJxFrWw04CZHPYiMRjYsaDvVV7hP1dYNRLxSANLaBFGpog=="],

    "@biomejs/cli-darwin-arm64": ["@biomejs/cli-darwin-arm64@1.9.4", "", { "os": "darwin", "cpu": "arm64" }, "sha512-bFBsPWrNvkdKrNCYeAp+xo2HecOGPAy9WyNyB/jKnnedgzl4W4Hb9ZMzYNbf8dMCGmUdSavlYHiR01QaYR58cw=="],

    "@biomejs/cli-darwin-x64": ["@biomejs/cli-darwin-x64@1.9.4", "", { "os": "darwin", "cpu": "x64" }, "sha512-ngYBh/+bEedqkSevPVhLP4QfVPCpb+4BBe2p7Xs32dBgs7rh9nY2AIYUL6BgLw1JVXV8GlpKmb/hNiuIxfPfZg=="],

    "@biomejs/cli-linux-arm64": ["@biomejs/cli-linux-arm64@1.9.4", "", { "os": "linux", "cpu": "arm64" }, "sha512-fJIW0+LYujdjUgJJuwesP4EjIBl/N/TcOX3IvIHJQNsAqvV2CHIogsmA94BPG6jZATS4Hi+xv4SkBBQSt1N4/g=="],

    "@biomejs/cli-linux-arm64-musl": ["@biomejs/cli-linux-arm64-musl@1.9.4", "", { "os": "linux", "cpu": "arm64" }, "sha512-v665Ct9WCRjGa8+kTr0CzApU0+XXtRgwmzIf1SeKSGAv+2scAlW6JR5PMFo6FzqqZ64Po79cKODKf3/AAmECqA=="],

    "@biomejs/cli-linux-x64": ["@biomejs/cli-linux-x64@1.9.4", "", { "os": "linux", "cpu": "x64" }, "sha512-lRCJv/Vi3Vlwmbd6K+oQ0KhLHMAysN8lXoCI7XeHlxaajk06u7G+UsFSO01NAs5iYuWKmVZjmiOzJ0OJmGsMwg=="],

    "@biomejs/cli-linux-x64-musl": ["@biomejs/cli-linux-x64-musl@1.9.4", "", { "os": "linux", "cpu": "x64" }, "sha512-gEhi/jSBhZ2m6wjV530Yy8+fNqG8PAinM3oV7CyO+6c3CEh16Eizm21uHVsyVBEB6RIM8JHIl6AGYCv6Q6Q9Tg=="],

    "@biomejs/cli-win32-arm64": ["@biomejs/cli-win32-arm64@1.9.4", "", { "os": "win32", "cpu": "arm64" }, "sha512-tlbhLk+WXZmgwoIKwHIHEBZUwxml7bRJgk0X2sPyNR3S93cdRq6XulAZRQJ17FYGGzWne0fgrXBKpl7l4M87Hg=="],

    "@biomejs/cli-win32-x64": ["@biomejs/cli-win32-x64@1.9.4", "", { "os": "win32", "cpu": "x64" }, "sha512-8Y5wMhVIPaWe6jw2H+KlEm4wP/f7EW3810ZLmDlrEEy5KvBsb9ECEfu/kMWD484ijfQ8+nIi0giMgu9g1UAuuA=="],

    "@types/bun": ["@types/bun@1.2.4", "", { "dependencies": { "bun-types": "1.2.4" } }, "sha512-QtuV5OMR8/rdKJs213iwXDpfVvnskPXY/S0ZiFbsTjQZycuqPbMW8Gf/XhLfwE5njW8sxI2WjISURXPlHypMFA=="],

    "@types/node": ["@types/node@22.13.10", "", { "dependencies": { "undici-types": "~6.20.0" } }, "sha512-I6LPUvlRH+O6VRUqYOcMudhaIdUVWfsjnZavnsraHvpBwaEyMN29ry+0UVJhImYL16xsscu0aske3yA+uPOWfw=="],

    "@types/ws": ["@types/ws@8.5.14", "", { "dependencies": { "@types/node": "*" } }, "sha512-bd/YFLW+URhBzMXurx7lWByOu+xzU9+kb3RboOteXYDfW+tr+JZa99OyNmPINEGB/ahzKrEuc8rcv4gnpJmxTw=="],

    "bun-types": ["bun-types@1.2.4", "", { "dependencies": { "@types/node": "*", "@types/ws": "~8.5.10" } }, "sha512-nDPymR207ZZEoWD4AavvEaa/KZe/qlrbMSchqpQwovPZCKc7pwMoENjEtHgMKaAjJhy+x6vfqSBA1QU3bJgs0Q=="],

    "typescript": ["typescript@5.8.2", "", { "bin": { "tsc": "bin/tsc", "tsserver": "bin/tsserver" } }, "sha512-aJn6wq13/afZp/jT9QZmwEjDqqvSGp1VT5GVg+f/t6/oVyrgXM6BY1h9BRh/O5p3PlUPAe+WuiEZOmb/49RqoQ=="],

    "undici-types": ["undici-types@6.20.0", "", {}, "sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg=="],
  }
}

================
File: package.json
================
{
	"name": "yatra",
	"module": "index.ts",
	"type": "module",
	"private": true,
	"devDependencies": {
		"@biomejs/biome": "^1.9.4",
		"@types/bun": "latest"
	},
	"peerDependencies": {
		"typescript": "^5"
	}
}

================
File: README.md
================
# yatra

================
File: tsconfig.json
================
{
	"compilerOptions": {
		// Enable latest features
		"lib": ["ESNext", "DOM"],
		"target": "ESNext",
		"module": "ESNext",
		"moduleDetection": "force",
		"jsx": "react-jsx",
		"allowJs": true,

		// Bundler mode
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"verbatimModuleSyntax": true,
		"noEmit": true,

		// Best practices
		"strict": true,
		"skipLibCheck": true,
		"noFallthroughCasesInSwitch": true,

		// Some stricter flags (disabled by default)
		"noUnusedLocals": false,
		"noUnusedParameters": false,
		"noPropertyAccessFromIndexSignature": false
	}
}
