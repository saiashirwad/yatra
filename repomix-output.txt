This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-27T11:21:35.781Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  columns/
    base-columns.ts
    column.ts
    properties.ts
    utils.ts
  index.ts
  pipe.ts
  pipeable.ts
  query.ts
  table.ts
  utils.ts
.gitignore
bun.lock
dprint.json
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: src/columns/base-columns.ts
================
import { Column, DataType } from "./column";
import { EnumValues } from "./properties";

class StringColumn extends Column<"string", string> {
  constructor() {
    super("string");
  }
}

class NumberColumn extends Column<"number", number> {
  constructor() {
    super("number");
  }
}

class BooleanColumn extends Column<"boolean", boolean> {
  constructor() {
    super("boolean");
  }
}

class DateColumn extends Column<"date", Date | number> {
  constructor() {
    super("date");
  }
}

class JsonColumn extends Column<"json", object | string> {
  constructor() {
    super("json");
  }
}

class JsonbColumn extends Column<"jsonb", object | string> {
  constructor() {
    super("jsonb");
  }
}

class UuidColumn extends Column<"uuid", string> {
  constructor() {
    super("uuid");
  }
}

class TextColumn extends Column<"text", string> {
  constructor() {
    super("text");
  }
}

class BigIntColumn extends Column<"bigint", bigint | number> {
  constructor() {
    super("bigint");
  }
}

class TimestampColumn extends Column<
  "timestamp",
  Date | string | number
> {
  private withTz: boolean;

  constructor(withTimezone: boolean = true) {
    super("timestamp");
    this.withTz = withTimezone;
  }

  withoutTimezone(): TimestampColumn {
    return new TimestampColumn(false);
  }

  get withTimezone(): boolean {
    return this.withTz;
  }
}

class TimeColumn extends Column<"time", string | Date> {
  private withTz: boolean;

  constructor(withTimezone: boolean = false) {
    super("time");
    this.withTz = withTimezone;
  }

  withTimezone(): TimeColumn {
    return new TimeColumn(true);
  }
}

class BinaryColumn extends Column<
  "binary",
  Uint8Array | Buffer | string
> {
  constructor() {
    super("binary");
  }
}

class DecimalColumn extends Column<"decimal", string | number> {
  constructor() {
    super("decimal");
  }
}

const LiteralValue = Symbol.for("Yatra/LiteralValue");
class LiteralColumn<
  T extends string | number | boolean,
> extends Column<"literal", T> {
  readonly [LiteralValue]: T;

  constructor(value: T) {
    super("literal");
    this[LiteralValue] = value;
  }
}

const ArrayItemType = Symbol.for("Yatra/ItemType");
class ArrayColumn<
  ItemType extends Column<any, any>,
> extends Column<
  "array",
  Array<ItemType[typeof DataType]>
> {
  readonly [ArrayItemType]: ItemType;

  constructor(itemType: ItemType) {
    super("array");
    this[ArrayItemType] = itemType;
  }
}

class EnumColumn<T extends string[]> extends Column<"enum", T[number]> {
  readonly [EnumValues]: T;

  constructor(values: T) {
    super("enum");
    this[EnumValues] = values;
  }
}

export function string(): StringColumn {
  return new StringColumn();
}

export function number(): NumberColumn {
  return new NumberColumn();
}

export function boolean(): BooleanColumn {
  return new BooleanColumn();
}

export function date(): DateColumn {
  return new DateColumn();
}

export function json(): JsonColumn {
  return new JsonColumn();
}

export function jsonb(): JsonbColumn {
  return new JsonbColumn();
}

export function uuid(): UuidColumn {
  return new UuidColumn();
}

export function text(): TextColumn {
  return new TextColumn();
}

export function bigint(): BigIntColumn {
  return new BigIntColumn();
}

export function timestamp(
  withTimezone: boolean = true,
): TimestampColumn {
  return new TimestampColumn(withTimezone);
}

export function time(
  withTimezone: boolean = false,
): TimeColumn {
  return new TimeColumn(withTimezone);
}

export function binary(): BinaryColumn {
  return new BinaryColumn();
}

export function decimal(): DecimalColumn {
  return new DecimalColumn();
}

export function literal<
  T extends string | number | boolean,
>(
  value: T,
): LiteralColumn<T> {
  return new LiteralColumn<T>(value);
}

export function array<T extends Column<any, any>>(
  itemType: T,
): ArrayColumn<T> {
  return new ArrayColumn<T>(itemType);
}

export function enum_<T extends string[]>(
  values: T,
): EnumColumn<T> {
  return new EnumColumn<T>(values);
}

================
File: src/columns/column.ts
================
import { type Pipeable, pipeArguments } from "../pipeable";

export const Type = Symbol.for("Yatra/Column/Type");
export const DataType = Symbol.for("Yatra/Column/DataType");

export class Column<
  CT extends ColumnType,
  DT extends any,
> implements Pipeable {
  readonly [Type]: CT;
  declare readonly [DataType]: DT;

  constructor(type: CT) {
    this[Type] = type;
    this[DataType] = null as any;
  }

  pipe(..._: Array<Function>) {
    return pipeArguments(
      this,
      arguments,
    );
  }
}

export type ColumnType =
  | "string"
  | "number"
  | "boolean"
  | "date"
  | "literal"
  | "json"
  | "jsonb"
  | "uuid"
  | "array"
  | "binary"
  | "text"
  | "bigint"
  | "timestamp"
  | "time"
  | "inet"
  | "cidr"
  | "macaddr"
  | "decimal"
  | "enum";

export type GetDataType<T> = T extends Column<any, infer DataType> ? DataType
  : never;

================
File: src/columns/properties.ts
================
import type { Column, DataType } from "./column";
import { extend } from "./utils";

export type ColumnPropertyName = string | symbol;

export const ColumnName = Symbol.for("Yatra/ColumnName");
export type ColumnName<T extends string> = { readonly [ColumnName]: T };
export const columnName =
  <Col extends Column<any, any>, const ColName extends string>(name: ColName) =>
  (c: Col) => extend<Col, ColumnName<ColName>>(c, ColumnName, name);

export const Nullable = Symbol.for("Yatra/Nullable");
export type Nullable = { readonly [Nullable]: true };
export type IsNullable<T> = T extends Nullable ? true : false;
export const nullable = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, Nullable>(c, Nullable, true);

export const Unique = Symbol.for("Yatra/Unique");
export type Unique = { readonly [Unique]: true };
export type IsUnique<T> = T extends Unique ? true : false;
export const unique = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, Unique>(c, Unique, true);

export const PrimaryKey = Symbol.for("Yatra/PrimaryKey");
export type PrimaryKey = { readonly [PrimaryKey]: true };
export type IsPrimaryKey<T> = T extends PrimaryKey ? true : false;
export const primaryKey = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, PrimaryKey>(c, PrimaryKey, true);

export const Default = Symbol.for("Yatra/Default");
export type Default<T> = { readonly [Default]: T };
export type GetDefault<T> = T extends Default<infer V> ? V : undefined;
export const defaultValue =
  <Col extends Column<any, any>, const V extends Col[typeof DataType]>(
    value: V,
  ) =>
  (c: Col) => extend<Col, Default<V>>(c, Default, value);

export const MinLength = Symbol.for("Yatra/MinLength");
export type MinLength<T extends number> = { readonly [MinLength]: T };
export type GetMinLength<T> = T extends MinLength<infer V> ? V : undefined;
export const minLength =
  <Col extends Column<"string" | "text", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) => extend<Col, MinLength<T>>(c, MinLength, value);

export const MaxLength = Symbol.for("Yatra/MaxLength");
export type MaxLength<T extends number> = { readonly [MaxLength]: T };
export type GetMaxLength<T> = T extends MaxLength<infer V> ? V : undefined;
export const maxLength =
  <Col extends Column<"string" | "text", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) => extend<Col, MaxLength<T>>(c, MaxLength, value);

export const Format = Symbol.for("Yatra/Format");
export type Format<T extends string> = { readonly [Format]: T };
export const format =
  <Col extends Column<any, any>, const Fmt extends string>(fmt: Fmt) =>
  (c: Col) => extend<Col, Format<Fmt>>(c, Format, fmt);

export const Enum = Symbol.for("Yatra/Enum");
export type Enum<T extends unknown[]> = { readonly [Enum]: T };

export const Min = Symbol.for("Yatra/Min");
export type Min<T extends number> = { readonly [Min]: T };
export const min =
  <Col extends Column<"number", any>, const M extends number>(minValue: M) =>
  (c: Col) => extend<Col, Min<M>>(c, Min, minValue);

export const Max = Symbol.for("Yatra/Max");
export type Max<T extends number> = { readonly [Max]: T };
export const max =
  <Col extends Column<"number", any>, const M extends number>(maxValue: M) =>
  (c: Col) => extend<Col, Max<M>>(c, Max, maxValue);

export const Integer = Symbol.for("Yatra/Integer");
export type Integer = { readonly [Integer]: true };
export const integer = <Col extends Column<"number", any>>(c: Col) =>
  extend<Col, Integer>(c, Integer, true);

export const References = Symbol.for("Yatra/References");
export type References<T extends string> = {
  readonly [References]: { table: T; column: string };
};
export type GetReferences<T> = T extends References<infer Table>
  ? { table: Table; column: string }
  : undefined;
export const references =
  <Col extends Column<any, any>, const T extends string>(
    table: T,
    column: string,
  ) =>
  (c: Col) => extend<Col, References<T>>(c, References, { table, column });

export const AutoIncrement = Symbol.for("Yatra/AutoIncrement");
export type AutoIncrement = { readonly [AutoIncrement]: true };
export type IsAutoIncrement<T> = T extends AutoIncrement ? true : false;
export const autoIncrement = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, AutoIncrement>(c, AutoIncrement, true);

export const Generated = Symbol.for("Yatra/Generated");
export type Generated<T extends string> = {
  readonly [Generated]: { expression: T };
};
export type GetGenerated<T> = T extends Generated<infer Expr> ? Expr
  : undefined;
export const generated =
  <Col extends Column<any, any>, const T extends string>(expression: T) =>
  (c: Col) => extend<Col, Generated<T>>(c, Generated, { expression });

export const Comment = Symbol.for("Yatra/Comment");
export type Comment<T extends string> = { readonly [Comment]: T };
export type GetComment<T> = T extends Comment<infer Text> ? Text : undefined;
export const comment =
  <Col extends Column<any, any>, const T extends string>(text: T) => (c: Col) =>
    extend<Col, Comment<T>>(c, Comment, text);

export const Precision = Symbol.for("Yatra/Precision");
export type Precision<T extends number> = { readonly [Precision]: T };
export type GetPrecision<T> = T extends Precision<infer P> ? P : undefined;
export const precision =
  <Col extends Column<"number" | "decimal", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) => extend<Col, Precision<T>>(c, Precision, value);

export const Scale = Symbol.for("Yatra/Scale");
export type Scale<T extends number> = { readonly [Scale]: T };
export type GetScale<T> = T extends Scale<infer S> ? S : undefined;
export const scale =
  <Col extends Column<"number" | "decimal", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) => extend<Col, Scale<T>>(c, Scale, value);

export const Check = Symbol.for("Yatra/Check");
export type Check<T extends string> = { readonly [Check]: T };
export const check =
  <Col extends Column<any, any>, const T extends string>(expression: T) =>
  (c: Col) => extend<Col, Check<T>>(c, Check, expression);

export const Index = Symbol.for("Yatra/Index");
export type Index = { readonly [Index]: true };
export const index = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, Index>(c, Index, true);

export const SearchIndexed = Symbol.for("Yatra/SearchIndexed");
export type SearchIndexed = { readonly [SearchIndexed]: true };
export const searchIndexed = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, SearchIndexed>(c, SearchIndexed, true);

export const LiteralValue = Symbol.for("Yatra/LiteralValue");
export const ItemType = Symbol.for("Yatra/ItemType");
export const EnumValues = Symbol.for("Yatra/EnumValues");

================
File: src/columns/utils.ts
================
import type { ColumnPropertyName } from "./properties";

export function extend<This, Brand>(
  instance: This,
  propertyName: ColumnPropertyName,
  propertyValue: unknown,
): This & Brand {
  const newInstance = Object.create(
    Object.getPrototypeOf(instance),
  );

  Object.assign(newInstance, instance);
  (newInstance as any)[propertyName] = propertyValue;

  return newInstance as This & Brand;
}

================
File: src/index.ts
================
import { date, number, string, uuid } from "./columns/base-columns";
import type { Column } from "./columns/column";
import { defaultValue, nullable, primaryKey } from "./columns/properties";
import { pipe } from "./pipe";
import { oneToMany, oneToOne, Relation, TableFields } from "./table";
import { Table } from "./table";

const basicColumns = {
  id: pipe(uuid(), primaryKey),
  name: pipe(string()),
  createdAt: pipe(date(), defaultValue(new Date())),
  updatedAt: pipe(date(), defaultValue(new Date())),
};

class Tag extends Table("Tag", {
  ...basicColumns,
}) {}

class Book extends Table(
  "book",
  {
    ...basicColumns,
    authorId: string(),
    description: pipe(string(), defaultValue("what"), nullable),
    price: pipe(number(), nullable),
  },
) {
  get author() {
    return oneToOne(() => Book, () => Author, "authorId");
  }

  get tags() {
    return oneToMany(() => Book, () => Tag, "id");
  }
}

class Author extends Table(
  "author",
  {
    ...basicColumns,
  },
) {}

const book = new Book({
  authorId: "asdf",
  createdAt: new Date(),
  id: "adsf",
  name: "asdf",
  updatedAt: new Date(),
});

type BookRelations = {
  [K in keyof Book as Book[K] extends Relation<any, any> ? K : never]: Book[K];
};

type BookColumns = Book[typeof TableFields];

const bookPrototype = Object.getPrototypeOf(book);

const descriptors = Object.getOwnPropertyDescriptors(bookPrototype);

for (const [k, v] of Object.entries(book)) {
  console.log(k, v);
}

console.log(descriptors);

================
File: src/pipe.ts
================
export function pipe<A>(a: A): A;
export function pipe<A, B = never>(
  a: A,
  ab: (a: A) => B,
): B;
export function pipe<A, B = never, C = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
): C;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
): D;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
): E;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
): F;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
): G;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
): H;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
): I;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
): J;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
): K;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
): L;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
): M;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
): N;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
): O;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
): P;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
): Q;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
): R;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
  S = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
  rs: (r: R) => S,
): S;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
  S = never,
  T = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
  rs: (r: R) => S,
  st: (s: S) => T,
): T;
export function pipe(
  a: unknown,
  ab?: Function,
  bc?: Function,
  cd?: Function,
  de?: Function,
  ef?: Function,
  fg?: Function,
  gh?: Function,
  hi?: Function,
): unknown {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab!(a);
    case 3:
      return bc!(ab!(a));
    case 4:
      return cd!(bc!(ab!(a)));
    case 5:
      return de!(cd!(bc!(ab!(a))));
    case 6:
      return ef!(de!(cd!(bc!(ab!(a)))));
    case 7:
      return fg!(ef!(de!(cd!(bc!(ab!(a))))));
    case 8:
      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))));
    case 9:
      return hi!(
        gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))),
      );
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

================
File: src/pipeable.ts
================
// https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Pipeable.ts

/**
 * @since 2.0.0
 */

/**
 * @since 2.0.0
 * @category models
 */
export interface Pipeable {
  pipe<A>(this: A): A;
  pipe<A, B = never>(this: A, ab: (_: A) => B): B;
  pipe<A, B = never, C = never>(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
  ): C;
  pipe<A, B = never, C = never, D = never>(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
  ): D;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
  ): E;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
  ): F;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
  ): G;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
  ): H;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
  ): I;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
  ): J;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
  ): K;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
  ): L;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
  ): M;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
  ): N;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
  ): O;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
  ): P;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
  ): Q;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
  ): R;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
  ): S;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
    T = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
    st: (_: S) => T,
  ): T;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
    T = never,
    U = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
    st: (_: S) => T,
    tu: (_: T) => U,
  ): U;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
    T = never,
    U = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
    st: (_: S) => T,
    tu: (_: T) => U,
  ): U;
}

/**
 * @since 2.0.0
 */
export const pipeArguments = <A>(
  self: A,
  args: IArguments,
): unknown => {
  switch (args.length) {
    case 0:
      return self;
    case 1:
      return args[0](self);
    case 2:
      return args[1](args[0](self));
    case 3:
      return args[2](args[1](args[0](self)));
    case 4:
      return args[3](
        args[2](args[1](args[0](self))),
      );
    case 5:
      return args[4](
        args[3](args[2](args[1](args[0](self)))),
      );
    case 6:
      return args[5](
        args[4](
          args[3](
            args[2](args[1](args[0](self))),
          ),
        ),
      );
    case 7:
      return args[6](
        args[5](
          args[4](
            args[3](
              args[2](args[1](args[0](self))),
            ),
          ),
        ),
      );
    case 8:
      return args[7](
        args[6](
          args[5](
            args[4](
              args[3](
                args[2](args[1](args[0](self))),
              ),
            ),
          ),
        ),
      );
    case 9:
      return args[8](
        args[7](
          args[6](
            args[5](
              args[4](
                args[3](
                  args[2](args[1](args[0](self))),
                ),
              ),
            ),
          ),
        ),
      );
    default: {
      let ret = self;
      for (
        let i = 0, len = args.length;
        i < len;
        i++
      ) {
        ret = args[i](ret);
      }
      return ret;
    }
  }
};

================
File: src/query.ts
================
// // query-builder.ts
// import { Column } from "./columns/column";
// import { TableFields, TableName } from "./types";
//
// // Utility types
// type Clean<T> = { [k in keyof T]: T[k] } & unknown;
//
// type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
//   k: infer I,
// ) => void ? I
//   : never;
//
// type GeneratorResult<R> = R extends Generator<infer V> ? V : never;
//
// type CleanResult<T extends (...args: any[]) => any> = Clean<
//   UnionToIntersection<GeneratorResult<ReturnType<T>>>
// >;
//
// // Helper function to preserve literal types
// function set<const R>(r: R) {
//   return r;
// }
//
// // Type constraint for table classes
// type TableClass = {
//   prototype: {
//     [TableFields]: Record<string, Column<any, any>>;
//     [TableName]: string;
//   };
// };
//
// // Query context type based on a table class
// type TableQueryContext<T extends TableClass> = {
//   tableClass: T;
//   columns: Record<string, Column<any, any>>;
//   query: any;
// };
//
// // Create a initial query context from a table class
// function from<T extends TableClass>(
//   tableClass: T,
// ): TableQueryContext<T> {
//   return {
//     tableClass,
//     columns: tableClass.prototype[TableFields],
//     query: { from: tableClass.prototype[TableName] },
//   };
// }
//
// // Select operation
// function* select<
//   T extends TableClass,
//   const S extends ReadonlyArray<
//     keyof T["prototype"][typeof TableFields] & string
//   >,
// >(
//   context: TableQueryContext<T>,
//   fields: S,
// ): Generator<{ select: S }, TableQueryContext<T>, any> {
//   yield set({ select: fields });
//   return {
//     ...context,
//     query: { ...context.query, select: fields },
//   };
// }
//
// // Where operation
// function* where<
//   T extends TableClass,
//   const C extends {
//     [K in keyof T["prototype"][typeof TableFields]]?: any;
//   },
// >(
//   context: TableQueryContext<T>,
//   condition: C,
// ): Generator<{ where: C }, TableQueryContext<T>, any> {
//   yield set({ where: condition });
//   return {
//     ...context,
//     query: { ...context.query, where: condition },
//   };
// }
//
// // Function to execute and collect the generator results
// function buildQuery<T extends (...args: any[]) => Generator<any, any, any>>(
//   gen: T,
// ): CleanResult<T> {
//   const generator = gen();
//   let result: any = {};
//
//   let next = generator.next();
//   while (!next.done) {
//     result = { ...result, ...next.value };
//     next = generator.next();
//   }
//
//   return result;
// }
//
// // Create a pipe-friendly version of the operations
// const selectFrom = <T extends TableClass>(tableClass: T) => from(tableClass);
//
// const withSelect = <
//   T extends TableClass,
//   S extends ReadonlyArray<keyof T["prototype"][typeof TableFields] & string>,
// >(
//   fields: S,
// ) =>
// (context: TableQueryContext<T>) => buildQuery(() => select(context, fields));
//
// const withWhere = <
//   T extends TableClass,
//   C extends { [K in keyof T["prototype"][typeof TableFields]]?: any },
// >(
//   condition: C,
// ) =>
// (context: TableQueryContext<T>) => buildQuery(() => where(context, condition));
//
// // Export everything
// export {
//   buildQuery,
//   from,
//   select,
//   selectFrom,
//   type TableQueryContext,
//   where,
//   withSelect,
//   withWhere,
// };

================
File: src/table.ts
================
import { Column } from "./columns/column";
import type { IsNullable } from "./columns/properties";
import { type Pipeable, pipeArguments } from "./pipeable";
import type { Clean } from "./utils";

export const SourceTable = Symbol.for("Yatra/Relation/SourceTable");
export const DestinationTable = Symbol.for("Yatra/Relation/DestinationTable");
export const TableFields = Symbol.for("Yatra/Table/Fields");

export class Relation<
  Source extends RelationTableConstructor,
  Destination extends RelationTableConstructor,
> implements Pipeable {
  public [SourceTable]: Source;
  public [DestinationTable]: Destination;

  constructor(
    source: () => Source,
    destination: () => Destination,
  ) {
    this[SourceTable] = source();
    this[DestinationTable] = destination();
  }

  pipe(...fns: Array<Function>) {
    return pipeArguments(
      this,
      arguments,
    );
  }

  get sourceTable() {
    return this[SourceTable];
  }

  get destinationTable() {
    return this[DestinationTable];
  }
}

export type FieldsRecord = Record<
  string,
  Column<any, any>
>;

type TableRelation<Self extends TableInstance<any, any>> = [
  type: "one-to-one",
  table: RelationTableConstructor,
  foreignKey: ExtractKeys<Self>,
] | [
  type: "one-to-many",
  table: RelationTableConstructor,
  foreignKey: ExtractKeys<Self>,
] | [
  type: "many-to-one",
  table: RelationTableConstructor,
  foreignKey: ExtractKeys<Self>,
];

export function Table<
  TableName extends string,
  Args extends FieldsRecord,
>(
  tableName: TableName,
  fields: Args,
): TableType<TableName, Args> {
  class TableClass {
    public [TableName]: TableName = tableName;
    public [TableFields]: Args = fields;

    constructor(
      args: MakeTableObject<Args>,
    ) {
      if (typeof args === "object") {
        for (const key in args) {
          const value = (args as any)[key];
          if (value instanceof Column) {
            console.log(key, value);
          }
          (this as any)[key] = (args as any)[key];
        }
      }
    }
  }

  return TableClass as unknown as TableType<
    TableName,
    Args
  >;
}

export type GetTableFields<T> = T extends TableType<any, infer Fields> ? Fields
  : never;

export type TableConstructor<F> = new(
  ...args: any[]
) => { fields: F };

export type InferColumn<C> = C extends Column<any, infer T>
  ? IsNullable<C> extends true ? T | null : T
  : never;

export type InferFields<CR extends Record<string, Column<any, any>>> = {
  [k in keyof CR]: InferColumn<CR[k]>;
};

export type NullableFields<
  Fields = FieldsRecord,
> = {
  -readonly [
    k in keyof Fields as IsNullable<
      Fields[k]
    > extends true ? k
      : never
  ]?: InferColumn<Fields[k]>;
};

export type NonNullableFields<Fields = FieldsRecord> = {
  -readonly [
    k in keyof Fields as IsNullable<
      Fields[k]
    > extends false ? k
      : never
  ]: InferColumn<Fields[k]>;
};

export type MakeTableObject<
  Fields = FieldsRecord,
  Nullable = NullableFields<Fields>,
  NonNullable = NonNullableFields<Fields>,
> = Clean<Nullable & NonNullable>;

export const TableName = Symbol.for("Yatra/Table/Name");

export type TableInstance<
  TableName extends string,
  Fields extends FieldsRecord,
> =
  & {
    [TableName]: TableName;
    [TableFields]: Fields;
  }
  & MakeTableObject<Fields>;

export interface TableType<
  TableName extends string,
  Fields extends FieldsRecord,
> {
  new(
    args: MakeTableObject<Fields>,
  ): TableInstance<TableName, Fields>;
}

export type RelationTableConstructor = new(
  args: any,
) => TableInstance<string, FieldsRecord>;

export type ExtractFields<T> = T extends TableType<any, infer F> ? F
  : never;

export type ExtractKeys<T> = keyof ExtractFields<T>;
export type ExtractTableName<T> = T extends TableType<infer N, any> ? N : never;

export class OneToOneRelation<
  S extends RelationTableConstructor,
  D extends RelationTableConstructor,
  FK extends ExtractKeys<S> = ExtractKeys<S>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public foreignKey: FK,
  ) {
    super(source, destination);
  }
}

export function oneToOne<
  S extends RelationTableConstructor,
  D extends RelationTableConstructor,
  FK extends ExtractKeys<S>,
>(
  source: () => S,
  destination: () => D,
  foreignKey: FK,
) {
  return new OneToOneRelation(source, destination, foreignKey);
}

export class OneToManyRelation<
  S extends RelationTableConstructor,
  D extends RelationTableConstructor,
  FK extends ExtractKeys<D> = ExtractKeys<D>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public foreignKey: FK,
  ) {
    super(source, destination);
  }
}

export function oneToMany<
  S extends RelationTableConstructor,
  D extends RelationTableConstructor,
  FK extends ExtractKeys<D>,
>(
  source: () => S,
  destination: () => D,
  foreignKey: FK,
) {
  return new OneToManyRelation(source, destination, foreignKey);
}

export class ManyToOneRelation<
  S extends RelationTableConstructor,
  D extends RelationTableConstructor,
  FK extends ExtractKeys<S> = ExtractKeys<S>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public foreignKey: FK,
  ) {
    super(source, destination);
  }
}

export function manyToOne<
  S extends RelationTableConstructor,
  D extends RelationTableConstructor,
  FK extends ExtractKeys<S>,
>(
  source: () => S,
  destination: () => D,
  foreignKey: FK,
) {
  return new ManyToOneRelation(source, destination, foreignKey);
}

export class ManyToManyRelation<
  S extends RelationTableConstructor,
  D extends RelationTableConstructor,
  JT extends string = string,
  SK extends ExtractKeys<S> = ExtractKeys<S>,
  DK extends ExtractKeys<D> = ExtractKeys<D>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public joinTable: JT,
    public sourceKey: SK,
    public destinationKey: DK,
  ) {
    super(source, destination);
  }
}

export function manyToMany<
  S extends RelationTableConstructor,
  D extends RelationTableConstructor,
  JT extends string,
  SK extends ExtractKeys<S>,
  DK extends ExtractKeys<D>,
>(
  source: () => S,
  destination: () => D,
  joinTable: JT,
  sourceKey: SK,
  destinationKey: DK,
) {
  return new ManyToManyRelation(
    source,
    destination,
    joinTable,
    sourceKey,
    destinationKey,
  );
}

================
File: src/utils.ts
================
export type Clean<T> =
  & { [k in keyof T]: T[k] }
  & unknown;

export type Class<
  O extends Record<string, unknown>,
> = {
  new(): InstanceType<new() => O>;
};

export type Constructor<
  Args = any,
  ReturnType = any,
> = new(
  ...args: Args[]
) => ReturnType;

/**
 * A curried type-safe wrapper around Reflect.construct
 *
 * @param constructor - The constructor function to invoke
 * @returns A function that accepts constructor arguments and returns an instance
 */
export function construct<T extends new(...args: any[]) => any>(
  constructor: T,
) {
  return <A extends ConstructorParameters<T>>(
    ...args: A
  ): InstanceType<T> => {
    return Reflect.construct(constructor, args) as InstanceType<T>;
  };
}

================
File: .gitignore
================
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

================
File: bun.lock
================
{
  "lockfileVersion": 1,
  "workspaces": {
    "": {
      "name": "dbschema",
      "dependencies": {
        "effect": "^3.14.1",
      },
      "devDependencies": {
        "@types/bun": "latest",
      },
      "peerDependencies": {
        "typescript": "^5.8.2",
      },
    },
  },
  "packages": {
    "@standard-schema/spec": ["@standard-schema/spec@1.0.0", "", {}, "sha512-m2bOd0f2RT9k8QJx1JN85cZYyH1RqFBdlwtkSlf4tBDYLCiiZnv1fIIwacK6cqwXavOydf0NPToMQgpKq+dVlA=="],

    "@types/bun": ["@types/bun@1.2.4", "", { "dependencies": { "bun-types": "1.2.4" } }, "sha512-QtuV5OMR8/rdKJs213iwXDpfVvnskPXY/S0ZiFbsTjQZycuqPbMW8Gf/XhLfwE5njW8sxI2WjISURXPlHypMFA=="],

    "@types/node": ["@types/node@22.13.10", "", { "dependencies": { "undici-types": "~6.20.0" } }, "sha512-I6LPUvlRH+O6VRUqYOcMudhaIdUVWfsjnZavnsraHvpBwaEyMN29ry+0UVJhImYL16xsscu0aske3yA+uPOWfw=="],

    "@types/ws": ["@types/ws@8.5.14", "", { "dependencies": { "@types/node": "*" } }, "sha512-bd/YFLW+URhBzMXurx7lWByOu+xzU9+kb3RboOteXYDfW+tr+JZa99OyNmPINEGB/ahzKrEuc8rcv4gnpJmxTw=="],

    "bun-types": ["bun-types@1.2.4", "", { "dependencies": { "@types/node": "*", "@types/ws": "~8.5.10" } }, "sha512-nDPymR207ZZEoWD4AavvEaa/KZe/qlrbMSchqpQwovPZCKc7pwMoENjEtHgMKaAjJhy+x6vfqSBA1QU3bJgs0Q=="],

    "effect": ["effect@3.14.1", "", { "dependencies": { "@standard-schema/spec": "^1.0.0", "fast-check": "^3.23.1" } }, "sha512-YrE6KYUu8r+fF3/cvdM+SZRZRjarVGhfcJwQjP/YyMmF79fwE1Rf0nWqLZ9Xfw7a9njm5/wmrYP83RYt5WTTbQ=="],

    "fast-check": ["fast-check@3.23.2", "", { "dependencies": { "pure-rand": "^6.1.0" } }, "sha512-h5+1OzzfCC3Ef7VbtKdcv7zsstUQwUDlYpUTvjeUsJAssPgLn7QzbboPtL5ro04Mq0rPOsMzl7q5hIbRs2wD1A=="],

    "pure-rand": ["pure-rand@6.1.0", "", {}, "sha512-bVWawvoZoBYpp6yIoQtQXHZjmz35RSVHnUOTefl8Vcjr8snTPY1wnpSPMWekcFwbxI6gtmT7rSYPFvz71ldiOA=="],

    "typescript": ["typescript@5.8.2", "", { "bin": { "tsc": "bin/tsc", "tsserver": "bin/tsserver" } }, "sha512-aJn6wq13/afZp/jT9QZmwEjDqqvSGp1VT5GVg+f/t6/oVyrgXM6BY1h9BRh/O5p3PlUPAe+WuiEZOmb/49RqoQ=="],

    "undici-types": ["undici-types@6.20.0", "", {}, "sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg=="],
  }
}

================
File: dprint.json
================
{
  "typescript": {
    "lineWidth": 80
  },
  "json": {},
  "markdown": {},
  "excludes": [
    "**/node_modules",
    "**/*-lock.json"
  ],
  "plugins": [
    "https://plugins.dprint.dev/typescript-0.94.0.wasm",
    "https://plugins.dprint.dev/json-0.20.0.wasm",
    "https://plugins.dprint.dev/markdown-0.18.0.wasm"
  ]
}

================
File: package.json
================
{
  "name": "yatra",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5.8.2"
  },
  "scripts": {
    "typecheck": "bun tsc --noEmit --incremental",
    "typecheck-watch": "bun tsc --noEmit --incremental --watch"
  },
  "dependencies": {
    "effect": "^3.14.1"
  }
}

================
File: README.md
================
# yatra

A playground for exploring ideas for a new, type-safe ORM for typescript.
Currently designed only with Postgres in mind

================
File: tsconfig.json
================
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
