This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-08T18:28:46.381Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
playground/
  blass.ts
  linq.ts
  phantom_types.ts
  play.ts
  scope.ts
src/
  columns/
    base-columns.ts
    column.ts
    properties.ts
  index.ts
  old_query.ts
  pipe.ts
  pipeable.ts
  query-2.ts
  query.ts
  relation.ts
  table-2.ts
  table.ts
  temp.ts
  utils.ts
.cursorrules
.gitignore
biome.json
bun.lock
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: playground/blass.ts
================
const data = {
  items: [{ name: "colinhacks" }],
  foo: { bar: true },
  get deeper() {
    return data;
  },
};

const out = get(data, "deeper.deeper.items.0.name");

type haha<path extends string> = conform<
  path,
  string & validatePath<typeof data, path>
>;

function get<const o extends object, path extends string>(
  data: o,
  pathStr: conform<path, string & validatePath<o, path>>,
): getPath<o, path> {
  let target: any = data;
  const path = pathStr.split(".");
  while (path.length) {
    target = target[path.shift()!];
  }
  return target;
}

/** Mimics the result of Object.keys(...) */
type keyOf<o> = o extends readonly unknown[]
  ? number extends o["length"]
    ? `${number}`
    : keyof o & `${number}`
  : {
      [k in keyof o]: k extends string ? k : k extends number ? `${k}` : never;
    }[keyof o];

type getKey<o, k> = k extends keyof o
  ? o[k]
  : k extends `${infer n extends number & keyof o}`
    ? o[n]
    : never;

type getPath<
  o,
  path extends string,
> = path extends `${infer head}.${infer tail}`
  ? getPath<getKey<o, head>, tail>
  : getKey<o, path>;

type validatePath<
  o,
  path extends string,
  prefix extends string = "",
> = path extends `${infer head}.${infer tail}`
  ? head extends keyOf<o>
    ? validatePath<getKey<o, head>, tail, `${prefix}${head}.`>
    : `Key '${head}' is not valid following '${prefix}'`
  : path extends keyOf<o>
    ? `${prefix}${path}`
    : {
        // find suffixes that would make the segment valid
        [k in keyOf<o>]: k extends `${path}${string}` ? `${prefix}${k}` : never;
      }[keyOf<o>];

type conform<t, base> = t extends base ? t : base;

================
File: playground/linq.ts
================
type Predicate<T> = (item: T) => boolean;
type Selector<T, R> = (item: T) => R;

type Clean<T> = { [k in keyof T]: T[k] } & unknown;

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;

type GeneratorResult<R> = R extends Generator<infer V> ? V : never;

type CleanResult<T extends (...args: any[]) => any> = Clean<
  UnionToIntersection<GeneratorResult<ReturnType<T>>>
>;

function set<const R>(r: R) {
  return r;
}

type QueryContext<T> = {
  data: T[];

  where: (
    predicate: Predicate<T>,
  ) => Generator<
    { type: "where"; predicate: Predicate<T>; result: T[] },
    QueryContext<T>,
    any
  >;

  select: <R>(selector: Selector<T, R>) => Generator<
    {
      type: "select";
      selector: Selector<T, R>;
      result: R[];
    },
    QueryContext<R>,
    any
  >;

  pickProps: <K extends keyof T>(
    keys: K[],
  ) => Generator<
    { type: "pick"; keys: K[]; result: Pick<T, K>[] },
    QueryContext<Pick<T, K>>,
    any
  >;

  orderBy: <K extends keyof T>(
    key: K,
    direction?: "asc" | "desc",
  ) => Generator<
    {
      type: "orderBy";
      key: K;
      direction: "asc" | "desc";
      result: T[];
    },
    QueryContext<T>,
    any
  >;

  limit: (
    count: number,
  ) => Generator<
    { type: "limit"; count: number; result: T[] },
    QueryContext<T>,
    any
  >;

  groupBy: <K extends keyof T>(
    key: K,
  ) => Generator<
    {
      type: "groupBy";
      key: K;
      result: Record<string, T[]>;
    },
    Record<string, T[]>,
    any
  >;
};

function createContext<T>(data: T[]): QueryContext<T> {
  return {
    data,

    *where(predicate: Predicate<T>) {
      const filtered = data.filter(predicate);
      yield set({
        type: "where",
        predicate,
        result: filtered,
      });
      return createContext(filtered);
    },

    *select<R>(selector: Selector<T, R>) {
      const mapped = data.map(selector);
      yield set({
        type: "select",
        selector,
        result: mapped,
      });
      return createContext(mapped);
    },

    *pickProps<K extends keyof T>(keys: K[]) {
      const picked = data.map(item => {
        const result = {} as Pick<T, K>;
        for (const key of keys) {
          result[key] = item[key];
        }
        return result;
      });
      yield set({
        type: "pick",
        keys,
        result: picked,
      });
      return createContext(picked);
    },

    *orderBy<K extends keyof T>(key: K, direction: "asc" | "desc" = "asc") {
      const sorted = [...data].sort((a, b) => {
        const valueA = a[key];
        const valueB = b[key];

        if (valueA === valueB) return 0;

        const comparison = valueA < valueB ? -1 : 1;
        return direction === "asc" ? comparison : -comparison;
      });
      yield set({
        type: "orderBy",
        key,
        direction,
        result: sorted,
      });
      return createContext(sorted);
    },

    *limit(count: number) {
      const limited = data.slice(0, count);
      yield set({
        type: "limit",
        count,
        result: limited,
      });
      return createContext(limited);
    },

    *groupBy<K extends keyof T>(key: K) {
      const grouped = data.reduce(
        (acc, item) => {
          const keyValue = String(item[key]);
          if (!acc[keyValue]) {
            acc[keyValue] = [];
          }
          acc[keyValue].push(item);
          return acc;
        },
        {} as Record<string, T[]>,
      );
      yield set({
        type: "groupBy",
        key,
        result: grouped,
      });
      return grouped;
    },
  };
}

function from<T, R>(
  source: T[],
  pipeline: (ctx: QueryContext<T>) => Generator<any, R, any>,
): R {
  const ctx = createContext(source);
  const iterator = pipeline(ctx);
  let current: any = ctx;

  let next = iterator.next();
  while (!next.done) {
    const value = next.value;

    if (value && typeof value === "object" && "result" in value) {
    }

    next = iterator.next(current);
  }

  return next.value !== undefined ? next.value : (current.data as unknown as R);
}

function query<T extends (...args: any[]) => any>(t: T): CleanResult<T> {
  return {} as any;
}

const people = [
  { name: "Alice", age: 30, department: "Engineering" },
  {
    name: "Bob",
    age: 40,
    department: "Marketing",
    hobby: "programming",
  },
  {
    name: "Carl",
    age: 20,
    department: "Engineering",
    hobby: "cooking",
  },
];

from(people, function* (ctx) {
  yield* ctx.pickProps(["name", "age"]);
  yield* ctx.where(p => p.age > 25);
});

================
File: playground/phantom_types.ts
================
class Entity<T extends Record<string, any>> {
  private data: T;

  declare _data: T;
  declare _nameType: T["name"];

  constructor(data: T) {
    this.data = data;
  }

  get name(): this["_nameType"] {
    return this.data["name"] as any;
  }
}

// const person = new Entity(
//   { name: "sai", age: 2342 } as const,
// );
// type nameType = (typeof person)["_nameType"];

================
File: playground/play.ts
================
type Clean<T> = { [k in keyof T]: T[k] } & unknown;

function set<const R>(r: R) {
  return r;
}

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;

type GeneratorResult<R> = R extends Generator<infer V> ? V : never;

type CleanResult<T extends (...args: any[]) => any> = Clean<
  UnionToIntersection<GeneratorResult<ReturnType<T>>>
>;

type TableSchema = Record<
  string,
  {
    columns: Record<string, any>;
  }
>;

let currentQueryContext: any = null;

type QueryContext<Schema extends TableSchema, T extends keyof Schema> = {
  schema: Schema;
  table: T;
  query: any;
};

function* select<
  Schema extends TableSchema,
  T extends keyof Schema,
  const S extends readonly (keyof Schema[T]["columns"])[],
>(context: QueryContext<Schema, T>, fields: S): Generator<{ select: S }> {
  yield set({ select: fields });
  currentQueryContext = { ...context, fields };
  return currentQueryContext;
}

function* where<
  Schema extends TableSchema,
  T extends keyof Schema,
  const C extends Record<string, any>,
>(context: QueryContext<Schema, T>, condition: C): Generator<{ where: C }> {
  yield set({ where: condition });
  return context;
}

function* orderBy<
  Schema extends TableSchema,
  T extends keyof Schema,
  const O extends Record<string, any>,
>(context: QueryContext<Schema, T>, orderByVal: O): Generator<{ orderBy: O }> {
  yield set({ orderBy: orderByVal });
  return context;
}

function* limit<
  Schema extends TableSchema,
  T extends keyof Schema,
  const L extends number,
>(context: QueryContext<Schema, T>, limitVal: L): Generator<{ limit: L }> {
  yield set({ limit: limitVal });
  return context;
}

type TestSchema = {
  users: {
    columns: {
      id: number;
      name: string;
      email: string;
      createdAt: Date;
    };
  };
  posts: {
    columns: {
      id: number;
      title: string;
      content: string;
      userId: number;
      published: boolean;
    };
  };
};

function query<T extends (...args: any[]) => any>(t: T): CleanResult<T> {
  return {} as any;
}

function createDb<Schema extends TableSchema>(schema: Schema) {
  return {
    selectFrom<T extends keyof Schema>(table: T) {
      function* _selectFrom() {
        const context: QueryContext<Schema, T> = {
          schema,
          table,
          query: { from: table },
        };
        currentQueryContext = context;
        yield set({ from: table });
        return context;
      }

      return _selectFrom();
    },
  };
}
const db = createDb<TestSchema>({} as TestSchema);

const example = query(function* () {
  const ctx = yield* db.selectFrom("posts");
  yield* select(ctx, ["id", "content", "title"]);
  yield* where(ctx, { published: true });
  yield* orderBy(ctx, { createdAt: "desc" });
});

================
File: playground/scope.ts
================
type BaseTypesMap = {
  string: string;
  number: number;
  boolean: boolean;
};
type BaseTypeName = keyof BaseTypesMap;

type DbScopeEntry =
  | string
  | {
      [k: string]: DbScopeEntry;
    };
type DbScopeSchema = Record<string, DbScopeEntry>;

type Trim<Str extends string> = Str extends ` ${infer Inner}`
  ? Trim<Inner>
  : Str extends `${infer Inner} `
    ? Trim<Inner>
    : Str;

type Resolve<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;

type AliasMap = {
  s: "string";
  n: "number";
  b: "boolean";
};
type AliasName = keyof AliasMap;

type ResolveAlias<T extends string> = T extends AliasName ? AliasMap[T] : T;

type ParseFieldDefinition<
  E extends string,
  S extends DbScopeSchema,
> = E extends `${infer Type}.${infer Modifiers}`
  ? {
      type: ParseFieldType<Type, S>;
      modifiers: ParseModifiers<Modifiers>;
    }
  : {
      type: ParseFieldType<E, S>;
      modifiers: {};
    };

type ParseFieldType<
  E extends string,
  S extends DbScopeSchema,
> = E extends `${infer Left} | ${infer Right}`
  ? ParseFieldType<Trim<Left>, S> | ParseFieldType<Trim<Right>, S>
  : E extends `${infer Inner}[]`
    ? ParseFieldType<Trim<Inner>, S>[]
    : ResolveAlias<Trim<E>> extends infer Resolved
      ? Resolved extends BaseTypeName
        ? BaseTypesMap[Resolved]
        : Resolved extends keyof S
          ? ParseEntry<S[Resolved], S>
          : never
      : never;

type ParseModifiers<Mods extends string> = Mods extends ""
  ? {}
  : Mods extends `${infer Mod}.${infer Rest}`
    ? ParseModifier<Mod> & ParseModifiers<Rest>
    : ParseModifier<Mods>;

type ParseModifier<Mod extends string> = Mod extends "id"
  ? { id: true }
  : Mod extends "unique"
    ? { unique: true }
    : Mod extends "default(uuid)"
      ? { default: "uuid" }
      : Mod extends "default(autoincrement)"
        ? { default: "autoincrement" }
        : Mod extends `relation(${infer ForeignKeyField}.${infer ReferencedField})`
          ? {
              relation: {
                foreignKeyField: ForeignKeyField;
                referencedField: ReferencedField;
              };
            }
          : Mod extends "relation"
            ? { relation: true }
            : {};

type ParseEntry<E, S extends DbScopeSchema> = E extends string
  ? ParseFieldDefinition<E, S>["type"]
  : E extends object
    ? Resolve<
        {
          -readonly [K in keyof E]: ParseEntry<E[K], S>;
        } & ResolveRelationFields<E, S>
      >
    : never;

type ResolveRelationFields<E, S extends DbScopeSchema> = {
  [K in keyof E as E[K] extends string
    ? ParseFieldDefinition<E[K], S>["modifiers"] extends {
        relation: {
          foreignKeyField: infer ForeignKeyField extends string; // Add constraint here
        };
      }
      ? ForeignKeyField
      : never
    : never]: string;
};

type ResolvedDbScope<S extends DbScopeSchema> = Resolve<{
  -readonly [K in keyof S]: ParseEntry<S[K], S>;
}>;

type PossibleFieldTypes<S> =
  | BaseTypeName
  | AliasName
  | keyof S
  | `${keyof S & string}[]`;

type PossibleModifiers =
  | "id"
  | "unique"
  | "default(uuid)"
  | "default(autoincrement)"
  | "relation"
  | `relation${string}`;

type PossibleFields<S, Model extends keyof S> = keyof S[Model];

type ValidateFieldDefinition<
  S,
  T extends string,
> = T extends `${infer Type}.${infer Modifiers}`
  ? `${ValidateType<S, Type>}${ValidateModifiers<S, Modifiers, Type>}`
  : ValidateType<S, T>;

type ValidateType<S, T extends string> = T extends PossibleFieldTypes<S>
  ? T
  : {
        [K in PossibleFieldTypes<S>]: K extends `${T}${string}` ? K : never;
      }[PossibleFieldTypes<S>] extends infer Suggestion
    ? Suggestion extends string
      ? Suggestion
      : `Invalid field type '${T}'. Did you mean one of: ${PossibleFieldTypes<S> &
          string}`
    : never;

type ExtractModel<Type extends string> = Type extends `${infer Model}[]`
  ? Model
  : Type;

type ValidateModifiers<
  S,
  Mods extends string,
  Type extends string,
> = Mods extends ""
  ? ""
  : Mods extends `${infer Mod extends string}.${infer Rest extends string}` // Add constraints here
    ? `.${ValidateModifier<S, Mod, Type>}${ValidateModifiers<S, Rest, Type>}`
    : `.${ValidateModifier<S, Mods, Type>}`;

type ValidateModifier<
  S,
  Mod extends string,
  Type extends string,
> = Mod extends PossibleModifiers
  ? Mod extends `relation(${infer ForeignKeyField}.${infer ReferencedField})`
    ? ExtractModel<Type> extends infer Model
      ? Type extends `${string}[]`
        ? "relation"
        : Model extends keyof S
          ? ForeignKeyField extends string
            ? ReferencedField extends PossibleFields<S, Model>
              ? Mod
              : `Invalid referenced field '${ReferencedField}' in model. Did you mean one of: ${PossibleFields<
                  S,
                  Model
                > &
                  string}`
            : `Invalid foreign key field '${ForeignKeyField}'`
          : `Invalid model in relation`
      : never
    : Mod
  : {
        [K in PossibleModifiers]: K extends `${Mod}${string}` ? K : never;
      }[PossibleModifiers] extends infer Suggestion
    ? Suggestion extends string
      ? Suggestion
      : `Invalid modifier. Did you mean one of: ${PossibleModifiers & string}`
    : never;

type ValidatedDbScopeSchema<S> = {
  [K in keyof S]: {
    [F in keyof S[K]]: S[K][F] extends string
      ? ValidateFieldDefinition<S, S[K][F]>
      : S[K][F] extends object
        ? ValidatedDbScopeSchema<S[K][F]>
        : never;
  };
};

function schema<const S extends DbScopeSchema>(
  schema: ValidatedDbScopeSchema<S>,
): ResolvedDbScope<S> {
  return schema as any;
}

const db = schema({
  user: {
    id: "string.id",
    name: "string",
    email: "string.unique",
    tags: "tag[]",
  },
  book: {
    id: "string.id",
    title: "string",
    tags: "tag[]",
  },
  tag: {
    id: "string.id",
    name: "string",
  },
});

type User = typeof db.user;
type Book = typeof db.book;
type Tag = typeof db.tag;

================
File: src/columns/base-columns.ts
================
import { Column, DataType } from "./column";
import { EnumValues } from "./properties";

class StringColumn extends Column<"string", string> {
  constructor() {
    super("string");
  }
}

class NumberColumn extends Column<"number", number> {
  constructor() {
    super("number");
  }
}

class BooleanColumn extends Column<"boolean", boolean> {
  constructor() {
    super("boolean");
  }
}

class DateColumn extends Column<"date", Date | number> {
  constructor() {
    super("date");
  }
}

class JsonColumn extends Column<"json", object | string> {
  constructor() {
    super("json");
  }
}

class JsonbColumn extends Column<"jsonb", object | string> {
  constructor() {
    super("jsonb");
  }
}

export class UuidColumn extends Column<"uuid", string> {
  constructor() {
    super("uuid");
  }
}

class TextColumn extends Column<"text", string> {
  constructor() {
    super("text");
  }
}

class BigIntColumn extends Column<"bigint", bigint | number> {
  constructor() {
    super("bigint");
  }
}

class TimestampColumn extends Column<"timestamp", Date | string | number> {
  private withTz: boolean;

  constructor(withTimezone: boolean = true) {
    super("timestamp");
    this.withTz = withTimezone;
  }

  withoutTimezone(): TimestampColumn {
    return new TimestampColumn(false);
  }

  get withTimezone(): boolean {
    return this.withTz;
  }
}

class TimeColumn extends Column<"time", string | Date> {
  private withTz: boolean;

  constructor(withTimezone: boolean = false) {
    super("time");
    this.withTz = withTimezone;
  }

  withTimezone(): TimeColumn {
    return new TimeColumn(true);
  }
}

class BinaryColumn extends Column<"binary", Uint8Array | Buffer | string> {
  constructor() {
    super("binary");
  }
}

class DecimalColumn extends Column<"decimal", string | number> {
  constructor() {
    super("decimal");
  }
}

const LiteralValue = Symbol.for("Yatra/LiteralValue");
class LiteralColumn<T extends string | number | boolean> extends Column<
  "literal",
  T
> {
  readonly [LiteralValue]: T;

  constructor(value: T) {
    super("literal");
    this[LiteralValue] = value;
  }
}

const ArrayItemType = Symbol.for("Yatra/ItemType");
class ArrayColumn<ItemType extends Column<any, any>> extends Column<
  "array",
  Array<ItemType[typeof DataType]>
> {
  readonly [ArrayItemType]: ItemType;

  constructor(itemType: ItemType) {
    super("array");
    this[ArrayItemType] = itemType;
  }
}

class EnumColumn<T extends string[]> extends Column<"enum", T[number]> {
  readonly [EnumValues]: T;

  constructor(values: T) {
    super("enum");
    this[EnumValues] = values;
  }
}

// export function string(): StringColumn {
//   return new StringColumn();
// }

export const string = new StringColumn();
export const number = new NumberColumn();
export const boolean = new BooleanColumn();
export const date = new DateColumn();
export const json = new JsonColumn();
export const jsonb = new JsonbColumn();
export const uuid = new UuidColumn();
export const text = new TextColumn();
export const bigint = new BigIntColumn();
export const timestamp = new TimestampColumn();
export const time = new TimeColumn();
export const binary = new BinaryColumn();
export const decimal = new DecimalColumn();

export function literal<T extends string | number | boolean>(
  value: T,
): LiteralColumn<T> {
  return new LiteralColumn<T>(value);
}

export function array<T extends Column<any, any>>(itemType: T): ArrayColumn<T> {
  return new ArrayColumn<T>(itemType);
}

export function enum_<T extends string[]>(values: T): EnumColumn<T> {
  return new EnumColumn<T>(values);
}

================
File: src/columns/column.ts
================
import { type Pipeable, pipeArguments } from "../pipeable";

export const Type = Symbol.for("Yatra/Column/Type");
export const DataType = Symbol.for("Yatra/Column/DataType");

export class Column<CT extends ColumnType, DT> implements Pipeable {
  readonly [Type]: CT;
  declare readonly [DataType]: DT;

  constructor(type: CT) {
    this[Type] = type;
    this[DataType] = null as any;
  }

  // biome-ignore lint/complexity/noBannedTypes: <explanation>
  pipe(..._: Array<Function>) {
    return pipeArguments(this, arguments);
  }
}

export type ColumnType =
  | "string"
  | "number"
  | "boolean"
  | "date"
  | "literal"
  | "json"
  | "jsonb"
  | "uuid"
  | "array"
  | "binary"
  | "text"
  | "bigint"
  | "timestamp"
  | "time"
  | "inet"
  | "cidr"
  | "macaddr"
  | "decimal"
  | "enum";

export type GetDataType<T> = T extends Column<any, infer DataType>
  ? DataType
  : never;

================
File: src/columns/properties.ts
================
import { extend } from "../utils";
import type { Column, DataType } from "./column";

export type ColumnPropertyName = string | symbol;

export const ColumnName = Symbol.for("Yatra/ColumnName");
export type ColumnName<T extends string> = {
  readonly [ColumnName]: T;
};
export const columnName =
  <Col extends Column<any, any>, const ColName extends string>(name: ColName) =>
  (c: Col) =>
    extend<Col, ColumnName<ColName>>(c, ColumnName, name);

export const Nullable = Symbol.for("Yatra/Nullable");
export type Nullable = {
  readonly [Nullable]: true;
};
export type IsNullable<T> = T extends Nullable ? true : false;
export const nullable = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, Nullable>(c, Nullable, true);

export const Unique = Symbol.for("Yatra/Unique");
export type Unique = {
  readonly [Unique]: true;
};
export type IsUnique<T> = T extends Unique ? true : false;
export const unique = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, Unique>(c, Unique, true);

export const PrimaryKey = Symbol.for("Yatra/PrimaryKey");
export type PrimaryKey = {
  readonly [PrimaryKey]: true;
};
export type IsPrimaryKey<T> = T extends PrimaryKey ? true : false;
export const primaryKey = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, PrimaryKey>(c, PrimaryKey, true);

export const Default = Symbol.for("Yatra/Default");
export type Default<T> = {
  readonly [Default]: T;
};
export type GetDefault<T> = T extends Default<infer V> ? V : undefined;
export const defaultValue =
  <Col extends Column<any, any>, const V extends Col[typeof DataType]>(
    value: V,
  ) =>
  (c: Col) =>
    extend<Col, Default<V>>(c, Default, value);

export const MinLength = Symbol.for("Yatra/MinLength");
export type MinLength<T extends number> = {
  readonly [MinLength]: T;
};
export type GetMinLength<T> = T extends MinLength<infer V> ? V : undefined;
export const minLength =
  <Col extends Column<"string" | "text", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) =>
    extend<Col, MinLength<T>>(c, MinLength, value);

export const MaxLength = Symbol.for("Yatra/MaxLength");
export type MaxLength<T extends number> = {
  readonly [MaxLength]: T;
};
export type GetMaxLength<T> = T extends MaxLength<infer V> ? V : undefined;
export const maxLength =
  <Col extends Column<"string" | "text", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) =>
    extend<Col, MaxLength<T>>(c, MaxLength, value);

export const Format = Symbol.for("Yatra/Format");
export type Format<T extends string> = {
  readonly [Format]: T;
};
export const format =
  <Col extends Column<any, any>, const Fmt extends string>(fmt: Fmt) =>
  (c: Col) =>
    extend<Col, Format<Fmt>>(c, Format, fmt);

export const Enum = Symbol.for("Yatra/Enum");
export type Enum<T extends unknown[]> = {
  readonly [Enum]: T;
};

export const Min = Symbol.for("Yatra/Min");
export type Min<T extends number> = {
  readonly [Min]: T;
};
export const min =
  <Col extends Column<"number", any>, const M extends number>(minValue: M) =>
  (c: Col) =>
    extend<Col, Min<M>>(c, Min, minValue);

export const Max = Symbol.for("Yatra/Max");
export type Max<T extends number> = {
  readonly [Max]: T;
};
export const max =
  <Col extends Column<"number", any>, const M extends number>(maxValue: M) =>
  (c: Col) =>
    extend<Col, Max<M>>(c, Max, maxValue);

export const Integer = Symbol.for("Yatra/Integer");
export type Integer = {
  readonly [Integer]: true;
};
export const integer = <Col extends Column<"number", any>>(c: Col) =>
  extend<Col, Integer>(c, Integer, true);

export const References = Symbol.for("Yatra/References");
export type References<T extends string> = {
  readonly [References]: {
    table: T;
    column: string;
  };
};
export type GetReferences<T> = T extends References<infer Table>
  ? {
      table: Table;
      column: string;
    }
  : undefined;
export const references =
  <Col extends Column<any, any>, const T extends string>(
    table: T,
    column: string,
  ) =>
  (c: Col) =>
    extend<Col, References<T>>(c, References, {
      table,
      column,
    });

export const AutoIncrement = Symbol.for("Yatra/AutoIncrement");
export type AutoIncrement = {
  readonly [AutoIncrement]: true;
};
export type IsAutoIncrement<T> = T extends AutoIncrement ? true : false;
export const autoIncrement = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, AutoIncrement>(c, AutoIncrement, true);

export const Generated = Symbol.for("Yatra/Generated");
export type Generated<T extends string> = {
  readonly [Generated]: {
    expression: T;
  };
};
export type GetGenerated<T> = T extends Generated<infer Expr>
  ? Expr
  : undefined;
export const generated =
  <Col extends Column<any, any>, const T extends string>(expression: T) =>
  (c: Col) =>
    extend<Col, Generated<T>>(c, Generated, {
      expression,
    });

export const Comment = Symbol.for("Yatra/Comment");
export type Comment<T extends string> = {
  readonly [Comment]: T;
};
export type GetComment<T> = T extends Comment<infer Text> ? Text : undefined;
export const comment =
  <Col extends Column<any, any>, const T extends string>(text: T) =>
  (c: Col) =>
    extend<Col, Comment<T>>(c, Comment, text);

export const Precision = Symbol.for("Yatra/Precision");
export type Precision<T extends number> = {
  readonly [Precision]: T;
};
export type GetPrecision<T> = T extends Precision<infer P> ? P : undefined;
export const precision =
  <Col extends Column<"number" | "decimal", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) =>
    extend<Col, Precision<T>>(c, Precision, value);

export const Scale = Symbol.for("Yatra/Scale");
export type Scale<T extends number> = {
  readonly [Scale]: T;
};
export type GetScale<T> = T extends Scale<infer S> ? S : undefined;
export const scale =
  <Col extends Column<"number" | "decimal", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) =>
    extend<Col, Scale<T>>(c, Scale, value);

export const Check = Symbol.for("Yatra/Check");
export type Check<T extends string> = {
  readonly [Check]: T;
};
export const check =
  <Col extends Column<any, any>, const T extends string>(expression: T) =>
  (c: Col) =>
    extend<Col, Check<T>>(c, Check, expression);

export const Index = Symbol.for("Yatra/Index");
export type Index = {
  readonly [Index]: true;
};
export const index = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, Index>(c, Index, true);

export const SearchIndexed = Symbol.for("Yatra/SearchIndexed");
export type SearchIndexed = {
  readonly [SearchIndexed]: true;
};
export const searchIndexed = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, SearchIndexed>(c, SearchIndexed, true);

export const LiteralValue = Symbol.for("Yatra/LiteralValue");
export const ItemType = Symbol.for("Yatra/ItemType");
export const EnumValues = Symbol.for("Yatra/EnumValues");

================
File: src/index.ts
================
import { date, number, string, uuid } from "./columns/base-columns";
import { defaultValue, nullable, primaryKey } from "./columns/properties";
import { pipe } from "./pipe";
import { query, select } from "./query-2";
import { oneToMany, oneToOne } from "./relation";
import { Table } from "./table";
import type { Tableish } from "./utils";

class Tag extends Table("tag", {
  id: pipe(uuid, primaryKey),
  name: pipe(string),
  createdAt: pipe(date, defaultValue(new Date())),
  updatedAt: pipe(date, defaultValue(new Date())),
}) {}

class Book extends Table("book", {
  id: pipe(uuid, primaryKey),
  name: pipe(string),
  createdAt: pipe(date, defaultValue(new Date())),
  updatedAt: pipe(date, defaultValue(new Date())),
  authorId: string,
  description: pipe(string, defaultValue("what"), nullable),
  price: pipe(number, nullable),
}) {
  get author() {
    return oneToOne(
      () => Book,
      () => Author,
      "book.authorId",
      "author.id",
    );
  }

  get tags() {
    return oneToMany(
      () => Book,
      () => Tag,
      "book.id",
      "tag.id",
    );
  }
}

class Author extends Table("author", {
  id: pipe(uuid, primaryKey),
  name: pipe(string),
  description: pipe(string, nullable),
  createdAt: pipe(date, defaultValue(new Date())),
  updatedAt: pipe(date, defaultValue(new Date())),
}) {
  get books() {
    return oneToMany(
      () => Author,
      () => Book,
      "author.id",
      "book.authorId",
    );
  }
}

const something = string.pipe(nullable, defaultValue("what"));

================
File: src/old_query.ts
================
// // query-builder.ts
// import { Column } from "./columns/column";
// import { TableFields, TableName } from "./types";
//
// // Utility types
// type Clean<T> = { [k in keyof T]: T[k] } & unknown;
//
// type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
//   k: infer I,
// ) => void ? I
//   : never;
//
// type GeneratorResult<R> = R extends Generator<infer V> ? V : never;
//
// type CleanResult<T extends (...args: any[]) => any> = Clean<
//   UnionToIntersection<GeneratorResult<ReturnType<T>>>
// >;
//
// // Helper function to preserve literal types
// function set<const R>(r: R) {
//   return r;
// }
//
// // Type constraint for table classes
// type TableClass = {
//   prototype: {
//     [TableFields]: Record<string, Column<any, any>>;
//     [TableName]: string;
//   };
// };
//
// // Query context type based on a table class
// type TableQueryContext<T extends TableClass> = {
//   tableClass: T;
//   columns: Record<string, Column<any, any>>;
//   query: any;
// };
//
// // Create a initial query context from a table class
// function from<T extends TableClass>(
//   tableClass: T,
// ): TableQueryContext<T> {
//   return {
//     tableClass,
//     columns: tableClass.prototype[TableFields],
//     query: { from: tableClass.prototype[TableName] },
//   };
// }
//
// // Select operation
// function* select<
//   T extends TableClass,
//   const S extends ReadonlyArray<
//     keyof T["prototype"][typeof TableFields] & string
//   >,
// >(
//   context: TableQueryContext<T>,
//   fields: S,
// ): Generator<{ select: S }, TableQueryContext<T>, any> {
//   yield set({ select: fields });
//   return {
//     ...context,
//     query: { ...context.query, select: fields },
//   };
// }
//
// // Where operation
// function* where<
//   T extends TableClass,
//   const C extends {
//     [K in keyof T["prototype"][typeof TableFields]]?: any;
//   },
// >(
//   context: TableQueryContext<T>,
//   condition: C,
// ): Generator<{ where: C }, TableQueryContext<T>, any> {
//   yield set({ where: condition });
//   return {
//     ...context,
//     query: { ...context.query, where: condition },
//   };
// }
//
// // Function to execute and collect the generator results
// function buildQuery<T extends (...args: any[]) => Generator<any, any, any>>(
//   gen: T,
// ): CleanResult<T> {
//   const generator = gen();
//   let result: any = {};
//
//   let next = generator.next();
//   while (!next.done) {
//     result = { ...result, ...next.value };
//     next = generator.next();
//   }
//
//   return result;
// }
//
// // Create a pipe-friendly version of the operations
// const selectFrom = <T extends TableClass>(tableClass: T) => from(tableClass);
//
// const withSelect = <
//   T extends TableClass,
//   S extends ReadonlyArray<keyof T["prototype"][typeof TableFields] & string>,
// >(
//   fields: S,
// ) =>
// (context: TableQueryContext<T>) => buildQuery(() => select(context, fields));
//
// const withWhere = <
//   T extends TableClass,
//   C extends { [K in keyof T["prototype"][typeof TableFields]]?: any },
// >(
//   condition: C,
// ) =>
// (context: TableQueryContext<T>) => buildQuery(() => where(context, condition));
//
// // Export everything
// export {
//   buildQuery,
//   from,
//   select,
//   selectFrom,
//   type TableQueryContext,
//   where,
//   withSelect,
//   withWhere,
// };

================
File: src/pipe.ts
================
/** biome-ignore-all lint/complexity/noBannedTypes: <explanation> */
export function pipe<A>(a: A): A;
export function pipe<A, B = never>(a: A, ab: (a: A) => B): B;
export function pipe<A, B = never, C = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
): C;
export function pipe<A, B = never, C = never, D = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
): D;
export function pipe<A, B = never, C = never, D = never, E = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
): E;
export function pipe<A, B = never, C = never, D = never, E = never, F = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
): F;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
): G;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
): H;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
): I;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
): J;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
): K;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
): L;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
): M;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
): N;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
): O;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
): P;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
): Q;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
): R;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
  S = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
  rs: (r: R) => S,
): S;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
  S = never,
  T = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
  rs: (r: R) => S,
  st: (s: S) => T,
): T;
export function pipe(
  a: unknown,
  ab?: Function,
  bc?: Function,
  cd?: Function,
  de?: Function,
  ef?: Function,
  fg?: Function,
  gh?: Function,
  hi?: Function,
): unknown {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab!(a);
    case 3:
      return bc!(ab!(a));
    case 4:
      return cd!(bc!(ab!(a)));
    case 5:
      return de!(cd!(bc!(ab!(a))));
    case 6:
      return ef!(de!(cd!(bc!(ab!(a)))));
    case 7:
      return fg!(ef!(de!(cd!(bc!(ab!(a))))));
    case 8:
      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))));
    case 9:
      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

================
File: src/pipeable.ts
================
// https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Pipeable.ts

/**
 * @since 2.0.0
 */

/**
 * @since 2.0.0
 * @category models
 */
export interface Pipeable {
  pipe<A>(this: A): A;
  pipe<A, B = never>(this: A, ab: (_: A) => B): B;
  pipe<A, B = never, C = never>(this: A, ab: (_: A) => B, bc: (_: B) => C): C;
  pipe<A, B = never, C = never, D = never>(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
  ): D;
  pipe<A, B = never, C = never, D = never, E = never>(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
  ): E;
  pipe<A, B = never, C = never, D = never, E = never, F = never>(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
  ): F;
  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never>(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
  ): G;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
  ): H;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
  ): I;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
  ): J;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
  ): K;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
  ): L;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
  ): M;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
  ): N;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
  ): O;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
  ): P;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
  ): Q;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
  ): R;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
  ): S;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
    T = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
    st: (_: S) => T,
  ): T;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
    T = never,
    U = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
    st: (_: S) => T,
    tu: (_: T) => U,
  ): U;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
    T = never,
    U = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
    st: (_: S) => T,
    tu: (_: T) => U,
  ): U;
}

/**
 * @since 2.0.0
 */
export const pipeArguments = <A>(self: A, args: IArguments): unknown => {
  switch (args.length) {
    case 0:
      return self;
    case 1:
      return args[0](self);
    case 2:
      return args[1](args[0](self));
    case 3:
      return args[2](args[1](args[0](self)));
    case 4:
      return args[3](args[2](args[1](args[0](self))));
    case 5:
      return args[4](args[3](args[2](args[1](args[0](self)))));
    case 6:
      return args[5](args[4](args[3](args[2](args[1](args[0](self))))));
    case 7:
      return args[6](
        args[5](args[4](args[3](args[2](args[1](args[0](self)))))),
      );
    case 8:
      return args[7](
        args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))),
      );
    case 9:
      return args[8](
        args[7](
          args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))),
        ),
      );
    default: {
      let ret = self;
      for (let i = 0, len = args.length; i < len; i++) {
        ret = args[i](ret);
      }
      return ret;
    }
  }
};

================
File: src/query-2.ts
================
import type { TableRelations } from "./relation";
import { TableName } from "./table";
import type { Tableish, TableishFields } from "./utils";

type QueryState = {
  readonly _selection?: unknown;
  readonly _joins?: unknown;
  readonly _where?: unknown;
  readonly _orderBy?: unknown;
};

export type QueryContext<
  T extends Tableish,
  State extends QueryState = {},
  Selected extends ReadonlyArray<string> = readonly [],
> = {
  readonly table: T;
  readonly selected: Selected;
  readonly state: State;
};

export function query<T extends Tableish>(table: T): QueryContext<T> {
  return {
    table,
    selected: [] as const,
    state: {},
  };
}

export function select<
  T extends Tableish,
  State extends QueryState,
  const Paths extends ReadonlyArray<string>,
>(
  ...paths: [
    ...{
      [K in keyof Paths]: Conform<Paths[K], string & ValidatePath<T, Paths[K]>>;
    },
  ]
) {
  return (
    ctx: QueryContext<T, State>,
  ): QueryContext<T, State & { _selection: true }, typeof paths> => {
    return {
      ...ctx,
      selected: paths,
      state: {
        ...ctx.state,
        _selection: true,
      } as State & { _selection: true },
    };
  };
}

export type QualifiedField<T extends Tableish> = T extends Tableish<
  infer TName,
  infer F
>
  ? {
      [K in keyof F & string]: `${TName}.${K}`;
    }[keyof F & string]
  : never;

export function qualifiedField<T extends Tableish>(
  table: T,
  field: QualifiedField<T>,
): QualifiedField<T> {
  return `${table.prototype[TableName]}.${field}` as QualifiedField<T>;
}

export type GetField<
  T extends Tableish,
  Key,
> = Key extends keyof TableishFields<T> ? TableishFields<T>[Key] : never;

export type GetRelation<
  T extends Tableish,
  Key,
> = Key extends keyof TableRelations<T>
  ? TableRelations<T>[Key]["destinationTable"]
  : never;

// New type to handle aliased fields
type AliasedField<T, Alias> = {
  readonly field: T;
  readonly alias: Alias;
};

// Modified GetPath to handle aliased fields
export type GetPath<
  T extends Tableish,
  Path,
> = Path extends `${infer BasePath} as ${infer Alias}`
  ? AliasedField<GetPath<T, BasePath>, Alias>
  : Path extends `${infer Head}.${infer Tail}`
    ? GetPath<GetRelation<T, Head>, Tail>
    : GetField<T, Path>;

// Modified ValidatePath to handle aliases
type ValidatePath<
  T extends Tableish,
  Path extends string,
  Prefix extends string = "",
> = Path extends `${infer BasePath} as ${infer Alias}`
  ? `${ValidatePath<T, BasePath, Prefix>} as ${Alias}`
  : Path extends `${infer Head}.${infer Tail}`
    ? Head extends keyof TableRelations<T>
      ? ValidatePath<GetRelation<T, Head>, Tail, `${Prefix}${Head}.`>
      : `Key '${Head}' is not valid following '${Prefix}'`
    : Path extends keyof TableishFields<T>
      ? `${Prefix}${Path}`
      : {
          [k in keyof TableishFields<T>]: k extends `${Path}${string}`
            ? `${Prefix}${k}`
            : never;
        }[keyof TableishFields<T>];

export type Conform<T, Base> = T extends Base ? T : Base;

export function get<const T extends Tableish, Path extends string>(
  table: T,
  pathStr: Conform<Path, string & ValidatePath<T, Path>>,
): GetPath<T, Path> {
  // Implementation will be added later
  // This should parse the path and handle aliases
  return {} as any;
}

================
File: src/query.ts
================
// import { Relation } from "./relation";
// import type { TableRelations } from "./relation";
// import { TableFields, TableName } from "./table";
// import type { Tableish, TableishFields } from "./utils";
//
// type QueryState = {
//   readonly _selection?: unknown;
//   readonly _joins?: unknown;
//   readonly _where?: unknown;
//   readonly _orderBy?: unknown;
// };
//
// export type QualifiedField<T extends Tableish> = T extends
//   Tableish<infer TName, infer F> ? {
//     [K in keyof F & string]: `${TName}.${K}`;
//   }[keyof F & string]
//   : never;
//
// export type FieldSelector<T extends Tableish> =
//   | keyof TableishFields<T> & string
//   | QualifiedField<T>
//   | keyof TableRelations<T> & string;
//
// export interface FieldAliasObject<T extends Tableish> {
//   field: FieldSelector<T>;
//   as: string;
// }
//
// export type FieldWithAlias<T extends Tableish> =
//   | FieldAliasObject<T>
//   | FieldSelector<T>;
//
// export type JoinType = "inner" | "left" | "right" | "full";
//
// export interface JoinClause<T extends Tableish> {
//   type: JoinType;
//   target: Tableish;
//   sourceKey: QualifiedField<T>;
//   targetKey: string;
// }
//
// export interface WhereCondition<T extends Tableish> {
//   field: FieldSelector<T>;
//   operator: string;
//   value: any;
// }
//
// export interface OrderByClause<T extends Tableish> {
//   field: FieldSelector<T>;
//   direction: "asc" | "desc";
// }
//
// export type QueryContext<
//   T extends Tableish,
//   State extends QueryState = {},
//   SelectedFields extends ReadonlyArray<FieldSelector<T>> =
//     readonly [],
//   Joins extends ReadonlyArray<JoinClause<T>> = readonly [],
//   WhereConditions extends ReadonlyArray<WhereCondition<T>> =
//     readonly [],
//   OrderByClauses extends ReadonlyArray<OrderByClause<T>> =
//     readonly [],
// > = {
//   readonly table: T;
//   readonly selected: SelectedFields;
//   readonly joins: Joins;
//   readonly whereConditions: WhereConditions;
//   readonly orderByClauses: OrderByClauses;
//   readonly state: State;
// };
//
// export function query<T extends Tableish>(
//   table: T,
// ): QueryContext<
//   T,
//   {},
//   readonly [],
//   readonly [],
//   readonly [],
//   readonly []
// > {
//   return {
//     table,
//     selected: [] as const,
//     joins: [] as const,
//     whereConditions: [] as const,
//     orderByClauses: [] as const,
//     state: {},
//   };
// }
//
// export function as<T extends string>(
//   field: T,
//   alias: string,
// ): FieldAliasObject<any> {
//   return { field, as: alias } as FieldAliasObject<any>;
// }
//
// export function select<
//   T extends Tableish,
//   State extends QueryState,
//   Joins extends ReadonlyArray<JoinClause<T>>,
//   WhereConditions extends ReadonlyArray<WhereCondition<T>>,
//   OrderByClauses extends ReadonlyArray<OrderByClause<T>>,
//   const Fields extends FieldSelector<T>[],
// >(
//   ...fields: Fields
// ) {
//   return <CurrentJoins extends Joins>(
//     ctx: QueryContext<
//       T,
//       State,
//       any,
//       CurrentJoins,
//       WhereConditions,
//       OrderByClauses
//     >,
//   ): QueryContext<
//     T,
//     State & { _selection: Fields },
//     readonly [...Fields],
//     readonly [
//       ...CurrentJoins,
//       ...ComputeJoins<T, Fields, CurrentJoins>,
//     ],
//     WhereConditions,
//     OrderByClauses
//   > => {
//     const newJoins = [...ctx.joins] as unknown as [
//       ...CurrentJoins,
//       ...ComputeJoins<T, Fields, CurrentJoins>,
//     ];
//     const relationFields = fields.filter(field => {
//       return typeof field === "string"
//         && ctx.table.prototype[field]
//         && typeof Object.getOwnPropertyDescriptor(
//             ctx.table.prototype,
//             field,
//           )
//             ?.get === "function";
//     });
//
//     for (const relationName of relationFields) {
//       if (typeof relationName === "string") {
//         const relation = ctx.table.prototype[relationName];
//         if (relation && relation instanceof Relation) {
//           const alreadyJoined = ctx.joins.some(join =>
//             join.target === relation.destinationTable
//           );
//
//           if (!alreadyJoined) {
//             let sourceKey = "";
//             let targetKey = "";
//
//             if (
//               "foreignKey" in relation
//               && "referencedKey" in relation
//             ) {
//               sourceKey = String(relation.foreignKey);
//               targetKey = String(relation.referencedKey);
//
//               (newJoins as any).push({
//                 type: "left",
//                 target: relation.destinationTable,
//                 sourceKey: sourceKey as QualifiedField<T>,
//                 targetKey,
//               });
//             }
//           }
//         }
//       }
//     }
//
//     return {
//       ...ctx,
//       selected: fields as readonly [...Fields],
//       joins: newJoins,
//       state: {
//         ...ctx.state,
//         _selection: fields,
//       } as State & { _selection: Fields },
//     };
//   };
// }
//
// type ComputeJoins<
//   T extends Tableish,
//   Fields extends ReadonlyArray<FieldSelector<T>>,
//   ExistingJoins extends ReadonlyArray<JoinClause<T>>,
// > = {
//   [K in keyof Fields]: Fields[K] extends
//     keyof TableRelations<T> & string
//     ? ExistingJoins extends
//       ReadonlyArray<{ target: infer Target }>
//       ? Target extends
//         TableRelations<T>[Fields[K]]["destinationTable"]
//         ? never // Already joined
//       : JoinClause<T> // Need to join
//     : JoinClause<T> // Need to join
//     : never;
// }[number][] extends infer R
//   ? R extends never[] ? readonly []
//   : R
//   : readonly [];
//
// export function orderBy<
//   T extends Tableish,
//   State extends QueryState,
//   SelectedFields extends ReadonlyArray<FieldSelector<T>>,
//   Joins extends ReadonlyArray<JoinClause<T>>,
//   WhereConditions extends ReadonlyArray<WhereCondition<T>>,
//   OrderByClauses extends ReadonlyArray<OrderByClause<T>>,
//   Field extends FieldSelector<T>,
//   Direction extends "asc" | "desc" = "asc",
// >(
//   field: Field,
//   direction: Direction = "asc" as Direction,
// ) {
//   return (
//     ctx: QueryContext<
//       T,
//       State,
//       SelectedFields,
//       Joins,
//       WhereConditions,
//       OrderByClauses
//     >,
//   ): QueryContext<
//     T,
//     State & { _orderBy: true },
//     SelectedFields,
//     Joins,
//     WhereConditions,
//     readonly [
//       ...OrderByClauses,
//       { field: Field; direction: Direction },
//     ]
//   > => {
//     const orderByClause = { field, direction } as const;
//
//     return {
//       ...ctx,
//       orderByClauses: [
//         ...ctx.orderByClauses,
//         orderByClause,
//       ] as readonly [
//         ...OrderByClauses,
//         { field: Field; direction: Direction },
//       ],
//       state: {
//         ...ctx.state,
//         _orderBy: true,
//       } as State & { _orderBy: true },
//     };
//   };
// }
//
// export function where<
//   T extends Tableish,
//   State extends QueryState,
//   SelectedFields extends ReadonlyArray<FieldSelector<T>>,
//   Joins extends ReadonlyArray<JoinClause<T>>,
//   WhereConditions extends ReadonlyArray<WhereCondition<T>>,
//   OrderByClauses extends ReadonlyArray<OrderByClause<T>>,
//   Field extends FieldSelector<T>,
//   Operator extends string,
//   Value extends any,
// >(
//   field: Field,
//   operator: Operator,
//   value: Value,
// ) {
//   return (
//     ctx: QueryContext<
//       T,
//       State,
//       SelectedFields,
//       Joins,
//       WhereConditions,
//       OrderByClauses
//     >,
//   ): QueryContext<
//     T,
//     State & { _where: true },
//     SelectedFields,
//     Joins,
//     readonly [
//       ...WhereConditions,
//       { field: Field; operator: Operator; value: Value },
//     ],
//     OrderByClauses
//   > => {
//     const whereCondition = {
//       field,
//       operator,
//       value,
//     } as const;
//
//     return {
//       ...ctx,
//       whereConditions: [
//         ...ctx.whereConditions,
//         whereCondition,
//       ] as readonly [
//         ...WhereConditions,
//         { field: Field; operator: Operator; value: Value },
//       ],
//       state: {
//         ...ctx.state,
//         _where: true,
//       } as State & { _where: true },
//     };
//   };
// }
//
// export function join<
//   T extends Tableish,
//   State extends QueryState,
//   SelectedFields extends ReadonlyArray<FieldSelector<T>>,
//   Joins extends ReadonlyArray<JoinClause<T>>,
//   WhereConditions extends ReadonlyArray<WhereCondition<T>>,
//   OrderByClauses extends ReadonlyArray<OrderByClause<T>>,
//   RelationName extends keyof TableRelations<T> & string,
//   JT extends JoinType = "inner",
// >(
//   relationName: RelationName,
//   joinType: JT = "inner" as JT,
// ) {
//   return (
//     ctx: QueryContext<
//       T,
//       State,
//       SelectedFields,
//       Joins,
//       WhereConditions,
//       OrderByClauses
//     >,
//   ): QueryContext<
//     T,
//     State & { _joins: true },
//     SelectedFields,
//     readonly [...Joins, {
//       type: JT;
//       target: TableRelations<
//         T
//       >[RelationName]["destinationTable"];
//       sourceKey: string;
//       targetKey: string;
//     }],
//     WhereConditions,
//     OrderByClauses
//   > => {
//     const relation = ctx.table
//       .prototype[relationName] as Relation<T, any>;
//
//     if (!relation) {
//       throw new Error(
//         `Relation ${String(relationName)} not found on ${
//           String(ctx.table.prototype[TableName])
//         }`,
//       );
//     }
//
//     let sourceKey = "";
//     let targetKey = "";
//
//     if (
//       "foreignKey" in relation
//       && "referencedKey" in relation
//     ) {
//       sourceKey = String(relation.foreignKey);
//       targetKey = String(relation.referencedKey);
//     } else {
//       throw new Error(
//         `Unsupported relation type for ${
//           String(relationName)
//         }`,
//       );
//     }
//
//     const joinClause = {
//       type: joinType,
//       target: relation.destinationTable,
//       sourceKey: sourceKey as QualifiedField<T>,
//       targetKey,
//     } as const;
//
//     return {
//       ...ctx,
//       joins: [...ctx.joins, joinClause] as readonly [
//         ...Joins,
//         {
//           type: JT;
//           target: TableRelations<
//             T
//           >[RelationName]["destinationTable"];
//           sourceKey: string;
//           targetKey: string;
//         },
//       ],
//       state: {
//         ...ctx.state,
//         _joins: true,
//       } as State & { _joins: true },
//     };
//   };
// }
//
// export function toSQL<
//   T extends Tableish,
//   State extends QueryState,
//   SelectedFields extends ReadonlyArray<FieldSelector<T>>,
//   Joins extends ReadonlyArray<JoinClause<T>>,
//   WhereConditions extends ReadonlyArray<WhereCondition<T>>,
//   OrderByClauses extends ReadonlyArray<OrderByClause<T>>,
// >(
//   ctx: QueryContext<
//     T,
//     State,
//     SelectedFields,
//     Joins,
//     WhereConditions,
//     OrderByClauses
//   >,
// ): string {
//   return "whaaat, i need to do this too?";
// }

================
File: src/relation.ts
================
import { type Pipeable, pipeArguments } from "./pipeable";
import type { Clean, QualifiedFieldName, Tableish } from "./utils";

export namespace Relations {
  export type OneToOne<
    Source extends Tableish,
    Destination extends Tableish,
    FK = QualifiedFieldName<Source>,
    RK = QualifiedFieldName<Destination>,
  > = Clean<{
    readonly type: "one-to-one";
    source: Source;
    destination: Destination;
    foreignKey: FK;
    referencedKey: RK;
  }>;
}
export const Relations = {
  oneToOne: <
    Source extends Tableish,
    Destination extends Tableish,
    FK = QualifiedFieldName<Source>,
    RK = QualifiedFieldName<Destination>,
  >(
    source: () => Source,
    destination: () => Destination,
    foreignKey: FK,
    referencedKey: RK,
  ): Relations.OneToOne<Source, Destination, FK, RK> => ({
    type: "one-to-one",
    source: source(),
    destination: destination(),
    foreignKey,
    referencedKey,
  }),
};

export class Relation<Source extends Tableish, Destination extends Tableish>
  implements Pipeable
{
  public sourceTable: Source;
  public destinationTable: Destination;

  constructor(source: () => Source, destination: () => Destination) {
    this.sourceTable = source();
    this.destinationTable = destination();
  }

  pipe(...fns: Array<Function>) {
    return pipeArguments(this, arguments);
  }
}

export class OneToOneRelation<
  S extends Tableish,
  D extends Tableish,
  const FK = QualifiedFieldName<S>,
  const RK = QualifiedFieldName<D>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public foreignKey: FK,
    public referencedKey: RK = "id" as any,
  ) {
    super(source, destination);
  }
}

export function oneToOne<
  S extends Tableish,
  D extends Tableish,
  const FK extends QualifiedFieldName<S>,
  const RK extends QualifiedFieldName<D>,
>(source: () => S, destination: () => D, foreignKey: FK, referencedKey: RK) {
  return new OneToOneRelation(source, destination, foreignKey, referencedKey);
}

export class OneToManyRelation<
  S extends Tableish,
  D extends Tableish,
  const FK extends QualifiedFieldName<S>,
  const RK extends QualifiedFieldName<D>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public foreignKey: FK,
    public referencedKey: RK = "id" as any,
  ) {
    super(source, destination);
  }
}

export function oneToMany<
  S extends Tableish,
  D extends Tableish,
  const FK extends QualifiedFieldName<S>,
  const RK extends QualifiedFieldName<D>,
>(
  source: () => S,
  destination: () => D,
  foreignKey: FK,
  referencedKey: RK = "id" as any,
) {
  return new OneToManyRelation(source, destination, foreignKey, referencedKey);
}

export class ManyToOneRelation<
  S extends Tableish,
  D extends Tableish,
  const FK extends QualifiedFieldName<S>,
  const RK extends QualifiedFieldName<D>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public foreignKey: FK,
    public referencedKey: RK = "id" as any,
  ) {
    super(source, destination);
  }
}

export function manyToOne<
  S extends Tableish,
  D extends Tableish,
  const FK extends QualifiedFieldName<S>,
  const RK extends QualifiedFieldName<D>,
>(
  source: () => S,
  destination: () => D,
  foreignKey: FK,
  referencedKey: RK = "id" as any,
) {
  return new ManyToOneRelation(source, destination, foreignKey, referencedKey);
}

export class ManyToManyRelation<
  S extends Tableish,
  D extends Tableish,
  const JT extends string,
  const SK extends QualifiedFieldName<S>,
  const DK extends QualifiedFieldName<D>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public joinTable: JT,
    public sourceKey: SK,
    public destinationKey: DK,
  ) {
    super(source, destination);
  }
}

export function manyToMany<
  S extends Tableish,
  D extends Tableish,
  const JT extends string,
  const SK extends QualifiedFieldName<S>,
  const DK extends QualifiedFieldName<D>,
>(
  source: () => S,
  destination: () => D,
  joinTable: JT,
  sourceKey: SK,
  destinationKey: DK,
) {
  return new ManyToManyRelation(
    source,
    destination,
    joinTable,
    sourceKey,
    destinationKey,
  );
}

export type TableRelations<T extends Tableish> = {
  -readonly [key in keyof T["prototype"] as T["prototype"][key] extends Relation<
    any,
    any
  >
    ? key
    : never]: Clean<T["prototype"][key]>;
} & {};

export function getRelation<
  T extends Tableish,
  const Relations extends keyof {
    [k in keyof T["prototype"]]: T[k];
  },
>(c: T, name: Relations): T["prototype"][Relations] {
  return c.prototype[name];
}

export function getRelationNames<T extends Tableish>(
  table: T,
): TableRelations<T> {
  return Reflect.ownKeys(table.prototype).filter(key => {
    return table.prototype[key] instanceof Relation;
  }) as any;
}

// type RelationType =
//   | "one-to-one"
//   | "one-to-many"
//   | "many-to-one"
//   | "many-to-many";
//
// type Reln<
//   Type extends RelationType,
//   Source extends Tableish,
//   Destination extends Tableish,
//   FK extends QualifiedFieldName<Source>,
//   DK extends QualifiedFieldName<Destination>,
//   JoinTable extends string | undefined,
// > =
//   & ({ source: () => Source; destination: () => Destination; fk: FK; rk: DK })
//   & ({
//     type: "one-to-one" | "one-to-many" | "many-to-one";
//   } | {
//     type: "many-to-many";
//     joinTable: Type extends "many-to-many" ? JoinTable : never;
//   });
//
// export class Relation2<
//   Type extends RelationType,
//   Source extends Tableish,
//   Destination extends Tableish,
//   FK extends QualifiedFieldName<Source>,
//   RK extends QualifiedFieldName<Destination>,
//   JoinTable extends string | undefined,
// > {
//   constructor(
//     public args: Reln<Type, Source, Destination, FK, RK, JoinTable>,
//   ) {}
// }
//
// export function relation<
//   Type extends RelationType,
//   Source extends Tableish,
//   Destination extends Tableish,
//   FK extends QualifiedFieldName<Source>,
//   RK extends QualifiedFieldName<Destination>,
//   JoinTable extends string | undefined,
// >(
//   type: Type,
//   source: () => Source,
//   destination: () => Destination,
//   args: Omit<
//     Reln<Type, Source, Destination, FK, RK, JoinTable>,
//     "type" | "source" | "destination"
//   >,
// ) {
//   return new Relation2({ type, source, destination, ...args } as any);
// }

================
File: src/table-2.ts
================
import { string, uuid } from "./columns/base-columns";
import type { Column } from "./columns/column";
import { primaryKey } from "./columns/properties";
import { pipe } from "./pipe";

namespace TableArgs {
  export type Fields = Record<string, Column<any, any>>;
  export type Relations = Record<string, any>;
  export type Indices = Record<string, any>;
}

interface TableParams<
  Fields extends TableArgs.Fields,
  Relations extends TableArgs.Relations,
  Indices extends TableArgs.Indices,
> {
  fields: Fields;
  relations?: Relations;
  indices?: Indices;
}

function table<
  Fields extends TableArgs.Fields,
  Relations extends TableArgs.Relations,
  Indices extends TableArgs.Indices,
>(
  params: TableParams<Fields, Relations, Indices>,
): {
  relations: Relations;
  indices: Indices;
  fields: Fields;
} {
  return {
    ...params,
    relations: params.relations ?? ({} as any),
    indices: params.indices ?? ({} as any),
  };
}

const Tags = table({
  fields: {
    id: pipe(uuid, primaryKey),
    name: string(),
  },
  relations: {},
});

const Book = table({
  fields: {
    id: pipe(uuid, primaryKey),
    name: string(),
  },
  relations: {
    tags: () => Tags,
  },
  indices: {},
});

================
File: src/table.ts
================
import { Column } from "./columns/column";
import type { IsNullable } from "./columns/properties";
import { Relation, type TableRelations } from "./relation";
import type { Clean, Tableish, TableishFields } from "./utils";

export const TableFields = Symbol.for("Yatra/Table/Fields");
export const TableRelationsSym = Symbol.for("Yatra/Table/Relations");
export const TableName = Symbol.for("Yatra/Table/Name");

export type FieldsRecord = Record<string, Column<any, any>>;

export type TableType<TableName extends string, Fields extends FieldsRecord> = {
  new (args: MakeTableObject<Fields>): TableInstance<TableName, Fields>;
  map<Result>(fn: (fields: Fields) => Result): Result;
  fields: Fields;
};

export type MakeTableObject<
  Fields = FieldsRecord,
  Nullable = NullableFields<Fields>,
  NonNullable = NonNullableFields<Fields>,
> = Clean<Nullable & NonNullable>;

export function Table<TableName extends string, Args extends FieldsRecord>(
  tableName: TableName,
  fields: Args,
): TableType<TableName, Args> {
  class TableClass {
    public [TableName]: TableName = tableName;
    public [TableFields]: Args = fields;
    public static fields: Args = fields;

    static map<Result>(fn: (fields: Args) => Result) {
      return fn(fields);
    }

    constructor(args: MakeTableObject<Args>) {
      if (typeof args === "object") {
        for (const key in args) {
          const value = (args as any)[key];
          if (value instanceof Column) {
            console.log(key, value);
          }
          (this as any)[key] = (args as any)[key];
        }
      }
    }
  }

  return TableClass as TableType<TableName, Args>;
}

export interface TableInfo<T extends Tableish> {
  fields: TableishFields<T>;
  relations: TableRelations<T>;
}

export function info<T extends Tableish>(table: T): TableInfo<T> {
  const keys = Reflect.ownKeys(table.prototype);
  let relations: any = {};
  for (const key of keys) {
    // @ts-ignore
    if (table.prototype[key] instanceof Relation) {
      // @ts-ignore
      relations[key] = table.prototype[key];
    }
  }
  // @ts-ignore
  const fields = table.fields;
  return { fields, relations };
}

export type GetTableFields<T> = T extends TableType<any, infer Fields>
  ? Fields
  : never;

export type TableConstructor<F> = new (...args: any[]) => { fields: F };

export type InferColumn<C> = C extends Column<any, infer T>
  ? IsNullable<C> extends true
    ? T | null
    : T
  : never;

export type InferFields<CR extends Record<string, Column<any, any>>> = {
  [k in keyof CR]: InferColumn<CR[k]>;
};

export type NullableFields<Fields = FieldsRecord> = {
  -readonly [k in keyof Fields as IsNullable<Fields[k]> extends true
    ? k
    : never]?: InferColumn<Fields[k]>;
};

export type NonNullableFields<Fields = FieldsRecord> = {
  -readonly [k in keyof Fields as IsNullable<Fields[k]> extends false
    ? k
    : never]: InferColumn<Fields[k]>;
};

export type TableInstance<
  TableName extends string,
  Fields extends FieldsRecord,
> = {
  [TableName]: TableName;
  [TableFields]: Fields;
} & MakeTableObject<Fields>;

export type ExtractFields<T> = T extends TableType<any, infer F> ? F : never;

================
File: src/temp.ts
================
// const result = pipe(
//   Author,
//   query,
//   select("id", "name", "books"),
//   select("description"),
//   orderBy("id", "desc"),
//   where("author.id", "=", "asdf"),
// );
//
// const asdf = pipe(
//   Book,
//   query,
//   select("id", "name", "author", "updatedAt", "tags"),
// );
//
// const lol = qualifiedField(Book, "book.authorId");
//
// type bookrelations = TableRelations<typeof Book>;
// type asdfasdf = GetRelation<typeof Book, "author">;
//
// type wer = GetPath<typeof Book, "author.description">;

================
File: src/utils.ts
================
import type { FieldsRecord, TableFields, TableName } from "./table";

export type Clean<T> = {
  [k in keyof T]: T[k];
} & unknown;

export type Class<O extends Record<string, unknown>> = {
  new (): InstanceType<new () => O>;
};

export type Constructor<Args = any, ReturnType = any> = new (
  ...args: Args[]
) => ReturnType;

/**
 * A curried type-safe wrapper around Reflect.construct
 *
 * @param constructor - The constructor function to invoke
 * @returns A function that accepts constructor arguments and returns an instance
 */

// biome-ignore lint/suspicious/noShadowRestrictedNames: <explanation>
export function construct<T extends new (...args: any[]) => any>(
  constructor: T,
) {
  return <A extends ConstructorParameters<T>>(...args: A): InstanceType<T> => {
    return Reflect.construct(constructor, args) as InstanceType<T>;
  };
}

export type ExtractKeys<T> = T extends {
  prototype: infer P;
}
  ? keyof P & string
  : string;

export interface Tableish<
  TableName extends string = string,
  Fields extends FieldsRecord = FieldsRecord,
> {
  new (
    ...args: any[]
  ): {
    [TableName]: TableName;
    [TableFields]: Fields;
  };
  prototype: any;
}

export type TableishFields<T> = T extends Tableish<any, infer F> ? F : never;

export type QualifiedFieldName<T> = T extends Tableish<infer N, infer F>
  ? `${N}.${keyof F & string}`
  : never;

export function extend<This, Brand>(
  instance: This,
  propertyName: string | symbol,
  propertyValue: unknown,
): This & Brand {
  const newInstance = Object.create(Object.getPrototypeOf(instance));
  Object.assign(newInstance, instance);
  (newInstance as any)[propertyName] = propertyValue;
  return newInstance as This & Brand;
}

================
File: .cursorrules
================
A next generation ORM typescript that is currently only designed for postgres.

We define schemas like this:
```typescript
class Author extends Table(
  "author",
  {
    id: pipe(uuid(), primaryKey),
    name: pipe(string()),
    createdAt: pipe(date(), defaultValue(new Date())),
    updatedAt: pipe(date(), defaultValue(new Date())),
  }
) {
  get books() {
    return relations.oneToMany(() => Author, () => Book, "id", "authorId");
  }
}
```

we take extreme type safety very seriously
for example, this is the definition of a field:

const idColumn = pipe(uuid(), primaryKey);

and the inferred type of said field is:
UuidColumn & PrimaryKey

here is another example:
const ageColumn = pipe(number(), min(21), max(29));

and the inferred type of said field is:
NumberColumn & Min<21> & Max<29>

This is how the query builder should work:
```typescript
const allAuthors = await Author.pipe(queryBuilder, select(ctx => ctx('id', 'name')), orderBy(ctx => ctx('name', 'asc')))
``` 
and all of those operations should be chainable and fully entirely type safe


because we also hold relationship information between different tables, we can do joins more ergonomically. if possible we also want the joins to happen automatically, like
```typescript
const allAuthors = await Author.pipe(queryBuilder, select(ctx => ctx('id', 'name', 'books')), orderBy(ctx => ctx('name', 'asc')))
```
in the above case, it would automatically join the books table and select the fields we need

each table would be pipeable, so we don't need to store the actual logic of the query builder inside the table. we can just pass in a context object that has the ability to select, orderBy, limit, offset, etc. thus, when we pass in the queryBuilder to the table, it injects the query context and thus we are able to then do the rest of the query building

all the query builder operations are functions. they give a context function that you then apply to the table.

================
File: .gitignore
================
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
.aider*

================
File: biome.json
================
{
  "$schema": "https://biomejs.dev/schemas/2.0.0-beta.1/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "space"
  },
  "assist": {
    "actions": {
      "source": {
        "organizeImports": "on"
      }
    }
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": false,
      "suspicious": {
        "noExplicitAny": "off"
      }
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double",
      "arrowParentheses": "asNeeded",
      "attributePosition": "multiline",
      "bracketSameLine": false,
      "lineWidth": 80,
      "indentStyle": "space",
      "trailingCommas": "all",
      "semicolons": "always"
    }
  }
}

================
File: bun.lock
================
{
  "lockfileVersion": 1,
  "workspaces": {
    "": {
      "name": "dbschema",
      "dependencies": {
        "effect": "^3.14.1",
        "yatra": ".",
      },
      "devDependencies": {
        "@biomejs/biome": "^2.0.0-beta.1",
        "@types/bun": "latest",
      },
      "peerDependencies": {
        "typescript": "^5.8.2",
      },
    },
  },
  "packages": {
    "@biomejs/biome": ["@biomejs/biome@2.0.0-beta.1", "", { "optionalDependencies": { "@biomejs/cli-darwin-arm64": "2.0.0-beta.1", "@biomejs/cli-darwin-x64": "2.0.0-beta.1", "@biomejs/cli-linux-arm64": "2.0.0-beta.1", "@biomejs/cli-linux-arm64-musl": "2.0.0-beta.1", "@biomejs/cli-linux-x64": "2.0.0-beta.1", "@biomejs/cli-linux-x64-musl": "2.0.0-beta.1", "@biomejs/cli-win32-arm64": "2.0.0-beta.1", "@biomejs/cli-win32-x64": "2.0.0-beta.1" }, "bin": { "biome": "bin/biome" } }, "sha512-MqRoy9CbTkrS45zW+S4u8p4kQUIFx0mGUWi789W1R3b1kXYIudEqsTKgXKtTGsI0kWOlvnjuKqwTrabjaGchhQ=="],

    "@biomejs/cli-darwin-arm64": ["@biomejs/cli-darwin-arm64@2.0.0-beta.1", "", { "os": "darwin", "cpu": "arm64" }, "sha512-RaGmpNLl5NFooXaoCwvgvcuU6Am/rMZ3R48pQeCVxjrCcz1BIlKLTai5UosiedazW7JbXAvgXdSNizYG7ITlAQ=="],

    "@biomejs/cli-darwin-x64": ["@biomejs/cli-darwin-x64@2.0.0-beta.1", "", { "os": "darwin", "cpu": "x64" }, "sha512-sTzSshkne7HKZFNfiIhmAji7gjtCBXvkTujZELCZWIZC7oj1Tjw/gvAzbdFj2UyHd5/i90pND4ybFOLQZm9gpg=="],

    "@biomejs/cli-linux-arm64": ["@biomejs/cli-linux-arm64@2.0.0-beta.1", "", { "os": "linux", "cpu": "arm64" }, "sha512-bxce2O4nooBmp20Ey0+IFIZyy/b0RVnciIQk9euCfAi9evq7SvFtMBYo3YUZej0KIvrau5H7tJk5OqmRJk2l+g=="],

    "@biomejs/cli-linux-arm64-musl": ["@biomejs/cli-linux-arm64-musl@2.0.0-beta.1", "", { "os": "linux", "cpu": "arm64" }, "sha512-0MPUKzz9uBBxAYSJ+OlFi4+yGwiRcZeFqq39H0MxXCQ9MMpKJFH2Ek72fw8sXwG7Prn7EsW/3u1b7najyn1XGQ=="],

    "@biomejs/cli-linux-x64": ["@biomejs/cli-linux-x64@2.0.0-beta.1", "", { "os": "linux", "cpu": "x64" }, "sha512-6P/AtJv4hOH8mu8ez0c4UInUpiet9NEoF25+O7OPyb4w6ZHJMp2qzvayJS7TKrTQzE5KUvSiNsACGRz34DzUkg=="],

    "@biomejs/cli-linux-x64-musl": ["@biomejs/cli-linux-x64-musl@2.0.0-beta.1", "", { "os": "linux", "cpu": "x64" }, "sha512-dFvisnP1hFpVILNw0PZfs8piBwe8+aykO04Tb/4AJDVVzKkGgJfwSefwo4jqzO/Wk/Zruvhcp1nKbjgRXM+vDg=="],

    "@biomejs/cli-win32-arm64": ["@biomejs/cli-win32-arm64@2.0.0-beta.1", "", { "os": "win32", "cpu": "arm64" }, "sha512-0C9YSqWHf2cJGnjKDbLi49xv6H9IfqbDsFav7X557PqwY64O6IKWqcmZzi/PkDFHjQM9opU6uhKapeGKGDxziQ=="],

    "@biomejs/cli-win32-x64": ["@biomejs/cli-win32-x64@2.0.0-beta.1", "", { "os": "win32", "cpu": "x64" }, "sha512-o8W6+DX0YRjt1kS8Y3ismq6EkjwiVDv7X0TEpfnFywoVG8HoJ7G7/m9r8LM1yE46WI3maPH2A0MoVpQ1ZNG++A=="],

    "@standard-schema/spec": ["@standard-schema/spec@1.0.0", "", {}, "sha512-m2bOd0f2RT9k8QJx1JN85cZYyH1RqFBdlwtkSlf4tBDYLCiiZnv1fIIwacK6cqwXavOydf0NPToMQgpKq+dVlA=="],

    "@types/bun": ["@types/bun@1.2.4", "", { "dependencies": { "bun-types": "1.2.4" } }, "sha512-QtuV5OMR8/rdKJs213iwXDpfVvnskPXY/S0ZiFbsTjQZycuqPbMW8Gf/XhLfwE5njW8sxI2WjISURXPlHypMFA=="],

    "@types/node": ["@types/node@22.13.10", "", { "dependencies": { "undici-types": "~6.20.0" } }, "sha512-I6LPUvlRH+O6VRUqYOcMudhaIdUVWfsjnZavnsraHvpBwaEyMN29ry+0UVJhImYL16xsscu0aske3yA+uPOWfw=="],

    "@types/ws": ["@types/ws@8.5.14", "", { "dependencies": { "@types/node": "*" } }, "sha512-bd/YFLW+URhBzMXurx7lWByOu+xzU9+kb3RboOteXYDfW+tr+JZa99OyNmPINEGB/ahzKrEuc8rcv4gnpJmxTw=="],

    "bun-types": ["bun-types@1.2.4", "", { "dependencies": { "@types/node": "*", "@types/ws": "~8.5.10" } }, "sha512-nDPymR207ZZEoWD4AavvEaa/KZe/qlrbMSchqpQwovPZCKc7pwMoENjEtHgMKaAjJhy+x6vfqSBA1QU3bJgs0Q=="],

    "effect": ["effect@3.14.1", "", { "dependencies": { "@standard-schema/spec": "^1.0.0", "fast-check": "^3.23.1" } }, "sha512-YrE6KYUu8r+fF3/cvdM+SZRZRjarVGhfcJwQjP/YyMmF79fwE1Rf0nWqLZ9Xfw7a9njm5/wmrYP83RYt5WTTbQ=="],

    "fast-check": ["fast-check@3.23.2", "", { "dependencies": { "pure-rand": "^6.1.0" } }, "sha512-h5+1OzzfCC3Ef7VbtKdcv7zsstUQwUDlYpUTvjeUsJAssPgLn7QzbboPtL5ro04Mq0rPOsMzl7q5hIbRs2wD1A=="],

    "pure-rand": ["pure-rand@6.1.0", "", {}, "sha512-bVWawvoZoBYpp6yIoQtQXHZjmz35RSVHnUOTefl8Vcjr8snTPY1wnpSPMWekcFwbxI6gtmT7rSYPFvz71ldiOA=="],

    "typescript": ["typescript@5.8.2", "", { "bin": { "tsc": "bin/tsc", "tsserver": "bin/tsserver" } }, "sha512-aJn6wq13/afZp/jT9QZmwEjDqqvSGp1VT5GVg+f/t6/oVyrgXM6BY1h9BRh/O5p3PlUPAe+WuiEZOmb/49RqoQ=="],

    "undici-types": ["undici-types@6.20.0", "", {}, "sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg=="],

    "yatra": ["yatra@file:", { "dependencies": { "effect": "^3.14.1" }, "devDependencies": { "@types/bun": "latest" }, "peerDependencies": { "typescript": "^5.8.2" } }],

    "yatra/@types/bun": ["@types/bun@1.2.8", "", { "dependencies": { "bun-types": "1.2.7" } }, "sha512-t8L1RvJVUghW5V+M/fL3Thbxcs0HwNsXsnTEBEfEVqGteiJToOlZ/fyOEaR1kZsNqnu+3XA4RI/qmnX4w6+S+w=="],

    "yatra/@types/bun/bun-types": ["bun-types@1.2.7", "", { "dependencies": { "@types/node": "*", "@types/ws": "*" } }, "sha512-P4hHhk7kjF99acXqKvltyuMQ2kf/rzIw3ylEDpCxDS9Xa0X0Yp/gJu/vDCucmWpiur5qJ0lwB2bWzOXa2GlHqA=="],
  }
}

================
File: package.json
================
{
  "name": "yatra",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@biomejs/biome": "^2.0.0-beta.1",
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5.8.2"
  },
  "scripts": {
    "typecheck": "bun tsc --noEmit --incremental",
    "typecheck-watch": "bun tsc --noEmit --incremental --watch"
  },
  "dependencies": {
    "effect": "^3.14.1",
    "yatra": "."
  }
}

================
File: README.md
================
# yatra

A playground for exploring ideas for a new, type-safe ORM for typescript. Currently designed only with Postgres in mind

## Query builder ideas

```typescript
class Book extends Table(
  "book",
  {
    id: pipe(uuid(), primaryKey),
    name: pipe(string()),
    createdAt: pipe(date(), defaultValue(new Date())),
    updatedAt: pipe(date(), defaultValue(new Date())),
    authorId: string(),
    description: pipe(string(), defaultValue("what"), nullable),
    price: pipe(number(), nullable),
  },
) {
  get author() {
    return oneToOne(
      () => Book, () => Author,
      "book.authorId", "author.id",
    );
  }

class Author extends Table(
  "author",
  {
    id: pipe(uuid(), primaryKey),
    name: pipe(string()),
    description: pipe(string(), nullable),
    createdAt: pipe(date(), defaultValue(new Date())),
    updatedAt: pipe(date(), defaultValue(new Date())),
  },
) {
  get books() {
    return oneToMany(
      () => Author, () => Book,
      "author.id", "book.authorId",
    );
  }
}

// option 1
const authorWithBooks = pipe(
  Author,
  query,
  select([
    "id",
    "name",
    {
      "books": [
        "id",
        "name",
        "authorId",
        {
          "tags": ["id", "name"],
        },
      ],
    },
  ]),
);

// option 2
const authorWithBooks = pipe(
  Author,
  query,
  select(
    "id",
    "name",
    jsonAgg("books", [
      "id",
      "name",
      "authorId",
      jsonAgg("tags", ["id", "name"]),
    ]),
  ),
);


// with hydration
const authorWithBooks = pipe(
  Author,
  query,
  hydrate,
  select(
    "id",
    "name",
    'books.id',
    'books.name',
    'books.tags.id'
  ),
);

{
  id: string
  name: string
  books: {
    id: string
    name: string
    tags: {
      id: string
    }
  }[]
}

// without hydration
const authorWithBooks = pipe(
  Author,
  query,
  select(
    "id",
    "name",
    as('books.id', 'bookId'),
    as('books.name', 'bookName'),
    as('books.tags.id','bookTagId')
  ),
);
// without hydrate
{
  id: string
  name: string
}
```

```sql
select id, name, books.id as bookId, books.name as bookName, tags.id as books__tags__name
where ... left joins
```

```sql
SELECT
    u.user_id,
    u.username,
    u.email,
    COALESCE(
        jsonb_agg(
            json_build_object(
                'book_id', b.book_id,
                'title', b.title,
                'author', b.author,
                'published_year', b.published_year,
                'pages', ( 
                    SELECT
                        COALESCE(
                            jsonb_agg(
                                json_build_object(
                                    'page_id', p.page_id,
                                    'page_number', p.page_number,
                                    'summary', p.content_summary
                                ) ORDER BY p.page_number 
                            ) FILTER (WHERE p.page_id IS NOT NULL), 
                            '[]'::jsonb 
                        )
                    FROM
                        pages p
                    WHERE
                        p.book_id = b.book_id 
                )   
            )
            ORDER BY b.title
        ) FILTER (WHERE b.book_id IS NOT NULL), 
        '[]'::jsonb 
    ) AS books_with_pages_json
FROM
    users u
LEFT JOIN
    books b ON u.user_id = b.user_id
GROUP BY
    u.user_id, u.username, u.email
ORDER BY
    u.username;
```

================
File: tsconfig.json
================
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
