This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-26T12:06:48.192Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
playground/
  phantom-types/
    ha.ts
  blass.ts
  linq.ts
  play.ts
  scope.ts
src/
  columns/
    base-columns.ts
    column.ts
    properties.ts
    utils.ts
  index.ts
  pipe.ts
  pipeable.ts
  relations.ts
  table.ts
  types.ts
  utils.ts
.gitignore
bun.lock
dprint.json
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: playground/phantom-types/ha.ts
================
class Entity<T extends Record<string, any>> {
  private data: T;

  declare _data: T;
  declare _nameType: T["name"];

  constructor(data: T) {
    this.data = data;
  }

  get name(): this["_nameType"] {
    return this.data["name"] as any;
  }
}

// const person = new Entity(
//   { name: "sai", age: 2342 } as const,
// );
// type nameType = (typeof person)["_nameType"];

================
File: playground/blass.ts
================
const data = {
  items: [{ name: "colinhacks" }],
  foo: { bar: true },
  get deeper() {
    return data;
  },
};

const out = get(
  data,
  "deeper.deeper.items.0.name",
);

type haha<path extends string> = conform<
  path,
  & string
  & validatePath<typeof data, path>
>;

function get<
  const o extends object,
  path extends string,
>(
  data: o,
  pathStr: conform<
    path,
    string & validatePath<o, path>
  >,
): getPath<o, path> {
  let target: any = data;
  const path = pathStr.split(".");
  while (path.length) {
    target = target[path.shift()!];
  }
  return target;
}

/** Mimics the result of Object.keys(...) */
type keyOf<o> = o extends readonly unknown[]
  ? number extends o["length"] ? `${number}`
  : keyof o & `${number}`
  : {
    [k in keyof o]: k extends string ? k
      : k extends number ? `${k}`
      : never;
  }[keyof o];

type getKey<o, k> = k extends keyof o ? o[k]
  : k extends `${infer n extends number & keyof o}` ? o[n]
  : never;

type getPath<o, path extends string> = path extends
  `${infer head}.${infer tail}` ? getPath<getKey<o, head>, tail>
  : getKey<o, path>;

type validatePath<
  o,
  path extends string,
  prefix extends string = "",
> = path extends `${infer head}.${infer tail}`
  ? head extends keyOf<o> ? validatePath<
      getKey<o, head>,
      tail,
      `${prefix}${head}.`
    >
  : `Key '${head}' is not valid following '${prefix}'`
  : path extends keyOf<o> ? `${prefix}${path}`
  : {
    // find suffixes that would make the segment valid
    [k in keyOf<o>]: k extends `${path}${string}` ? `${prefix}${k}`
      : never;
  }[keyOf<o>];

type conform<t, base> = t extends base ? t : base;

================
File: playground/linq.ts
================
type Predicate<T> = (item: T) => boolean;
type Selector<T, R> = (item: T) => R;

type Clean<T> = { [k in keyof T]: T[k] } & unknown;

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends
  (k: infer I) => void ? I
  : never;

type GeneratorResult<R> = R extends Generator<infer V> ? V
  : never;

type CleanResult<T extends (...args: any[]) => any> = Clean<
  UnionToIntersection<GeneratorResult<ReturnType<T>>>
>;

function set<const R>(r: R) {
  return r;
}

type QueryContext<T> = {
  data: T[];

  where: (predicate: Predicate<T>) => Generator<
    { type: "where"; predicate: Predicate<T>; result: T[] },
    QueryContext<T>,
    any
  >;

  select: <R>(selector: Selector<T, R>) => Generator<
    {
      type: "select";
      selector: Selector<T, R>;
      result: R[];
    },
    QueryContext<R>,
    any
  >;

  pickProps: <K extends keyof T>(keys: K[]) => Generator<
    { type: "pick"; keys: K[]; result: Pick<T, K>[] },
    QueryContext<Pick<T, K>>,
    any
  >;

  orderBy: <K extends keyof T>(
    key: K,
    direction?: "asc" | "desc",
  ) => Generator<
    {
      type: "orderBy";
      key: K;
      direction: "asc" | "desc";
      result: T[];
    },
    QueryContext<T>,
    any
  >;

  limit: (count: number) => Generator<
    { type: "limit"; count: number; result: T[] },
    QueryContext<T>,
    any
  >;

  groupBy: <K extends keyof T>(key: K) => Generator<
    {
      type: "groupBy";
      key: K;
      result: Record<string, T[]>;
    },
    Record<string, T[]>,
    any
  >;
};

function createContext<T>(data: T[]): QueryContext<T> {
  return {
    data,

    *where(predicate: Predicate<T>) {
      const filtered = data.filter(predicate);
      yield set({
        type: "where",
        predicate,
        result: filtered,
      });
      return createContext(filtered);
    },

    *select<R>(selector: Selector<T, R>) {
      const mapped = data.map(selector);
      yield set({
        type: "select",
        selector,
        result: mapped,
      });
      return createContext(mapped);
    },

    *pickProps<K extends keyof T>(keys: K[]) {
      const picked = data.map(item => {
        const result = {} as Pick<T, K>;
        for (const key of keys) {
          result[key] = item[key];
        }
        return result;
      });
      yield set({
        type: "pick",
        keys,
        result: picked,
      });
      return createContext(picked);
    },

    *orderBy<K extends keyof T>(
      key: K,
      direction: "asc" | "desc" = "asc",
    ) {
      const sorted = [...data].sort((a, b) => {
        const valueA = a[key];
        const valueB = b[key];

        if (valueA === valueB) return 0;

        const comparison = valueA < valueB ? -1 : 1;
        return direction === "asc"
          ? comparison
          : -comparison;
      });
      yield set({
        type: "orderBy",
        key,
        direction,
        result: sorted,
      });
      return createContext(sorted);
    },

    *limit(count: number) {
      const limited = data.slice(0, count);
      yield set({
        type: "limit",
        count,
        result: limited,
      });
      return createContext(limited);
    },

    *groupBy<K extends keyof T>(key: K) {
      const grouped = data.reduce((acc, item) => {
        const keyValue = String(item[key]);
        if (!acc[keyValue]) {
          acc[keyValue] = [];
        }
        acc[keyValue].push(item);
        return acc;
      }, {} as Record<string, T[]>);
      yield set({
        type: "groupBy",
        key,
        result: grouped,
      });
      return grouped;
    },
  };
}

function from<T, R>(
  source: T[],
  pipeline: (
    ctx: QueryContext<T>,
  ) => Generator<any, R, any>,
): R {
  const ctx = createContext(source);
  const iterator = pipeline(ctx);
  let current: any = ctx;

  let next = iterator.next();
  while (!next.done) {
    const value = next.value;

    if (
      value && typeof value === "object"
      && "result" in value
    ) {
    }

    next = iterator.next(current);
  }

  return next.value !== undefined
    ? next.value
    : current.data as unknown as R;
}

function query<T extends (...args: any[]) => any>(
  t: T,
): CleanResult<T> {
  return {} as any;
}

const people = [
  { name: "Alice", age: 30, department: "Engineering" },
  {
    name: "Bob",
    age: 40,
    department: "Marketing",
    hobby: "programming",
  },
  {
    name: "Carl",
    age: 20,
    department: "Engineering",
    hobby: "cooking",
  },
];

from(people, function*(ctx) {
  yield* ctx.pickProps(["name", "age"]);
  yield* ctx.where(p => p.age > 25);
});

================
File: playground/play.ts
================
type Clean<T> =
  & { [k in keyof T]: T[k] }
  & unknown;

function set<const R>(r: R) {
  return r;
}

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void ? I
  : never;

type GeneratorResult<R> = R extends Generator<infer V> ? V
  : never;

type CleanResult<
  T extends (...args: any[]) => any,
> = Clean<
  UnionToIntersection<
    GeneratorResult<ReturnType<T>>
  >
>;

type TableSchema = Record<
  string,
  {
    columns: Record<string, any>;
  }
>;

let currentQueryContext: any = null;

type QueryContext<
  Schema extends TableSchema,
  T extends keyof Schema,
> = {
  schema: Schema;
  table: T;
  query: any;
};

function* select<
  Schema extends TableSchema,
  T extends keyof Schema,
  const S extends readonly (keyof Schema[T][
    "columns"
  ])[],
>(
  context: QueryContext<Schema, T>,
  fields: S,
): Generator<{ select: S }> {
  yield set({ select: fields });
  currentQueryContext = { ...context, fields };
  return currentQueryContext;
}

function* where<
  Schema extends TableSchema,
  T extends keyof Schema,
  const C extends Record<string, any>,
>(
  context: QueryContext<Schema, T>,
  condition: C,
): Generator<{ where: C }> {
  yield set({ where: condition });
  return context;
}

function* orderBy<
  Schema extends TableSchema,
  T extends keyof Schema,
  const O extends Record<string, any>,
>(
  context: QueryContext<Schema, T>,
  orderByVal: O,
): Generator<{ orderBy: O }> {
  yield set({ orderBy: orderByVal });
  return context;
}

function* limit<
  Schema extends TableSchema,
  T extends keyof Schema,
  const L extends number,
>(
  context: QueryContext<Schema, T>,
  limitVal: L,
): Generator<{ limit: L }> {
  yield set({ limit: limitVal });
  return context;
}

type TestSchema = {
  users: {
    columns: {
      id: number;
      name: string;
      email: string;
      createdAt: Date;
    };
  };
  posts: {
    columns: {
      id: number;
      title: string;
      content: string;
      userId: number;
      published: boolean;
    };
  };
};

function query<T extends (...args: any[]) => any>(
  t: T,
): CleanResult<T> {
  return {} as any;
}

function createDb<Schema extends TableSchema>(
  schema: Schema,
) {
  return {
    selectFrom<T extends keyof Schema>(table: T) {
      function* _selectFrom() {
        const context: QueryContext<Schema, T> = {
          schema,
          table,
          query: { from: table },
        };
        currentQueryContext = context;
        yield set({ from: table });
        return context;
      }

      return _selectFrom();
    },
  };
}
const db = createDb<TestSchema>({} as TestSchema);

const example = query(function*() {
  const ctx = yield* db.selectFrom("posts");
  yield* select(ctx, ["id", "content", "title"]);
  yield* where(ctx, { published: true });
  yield* orderBy(ctx, { createdAt: "desc" });
});

typeof example;
//     ^?
//

function add(a: number, b: number) {
  return a + b;
}

================
File: playground/scope.ts
================
type BaseTypesMap = {
  string: string;
  number: number;
  boolean: boolean;
};
type BaseTypeName = keyof BaseTypesMap;

type DbScopeEntry = string | {
  [k: string]: DbScopeEntry;
};
type DbScopeSchema = Record<string, DbScopeEntry>;

type Trim<Str extends string> = Str extends ` ${infer Inner}` ? Trim<Inner>
  : Str extends `${infer Inner} ` ? Trim<Inner>
  : Str;

type Resolve<T> = T extends infer U ? { [K in keyof U]: U[K] }
  : never;

type AliasMap = {
  s: "string";
  n: "number";
  b: "boolean";
};
type AliasName = keyof AliasMap;

type ResolveAlias<T extends string> = T extends AliasName ? AliasMap[T]
  : T;

type ParseFieldDefinition<
  E extends string,
  S extends DbScopeSchema,
> = E extends `${infer Type}.${infer Modifiers}` ? {
    type: ParseFieldType<Type, S>;
    modifiers: ParseModifiers<Modifiers>;
  }
  : {
    type: ParseFieldType<E, S>;
    modifiers: {};
  };

type ParseFieldType<
  E extends string,
  S extends DbScopeSchema,
> = E extends `${infer Left} | ${infer Right}` ?
    | ParseFieldType<Trim<Left>, S>
    | ParseFieldType<Trim<Right>, S>
  : E extends `${infer Inner}[]` ? ParseFieldType<Trim<Inner>, S>[]
  : ResolveAlias<Trim<E>> extends infer Resolved
    ? Resolved extends BaseTypeName ? BaseTypesMap[Resolved]
    : Resolved extends keyof S ? ParseEntry<S[Resolved], S>
    : never
  : never;

type ParseModifiers<Mods extends string> = Mods extends "" ? {}
  : Mods extends `${infer Mod}.${infer Rest}`
    ? ParseModifier<Mod> & ParseModifiers<Rest>
  : ParseModifier<Mods>;

type ParseModifier<Mod extends string> = Mod extends "id" ? { id: true }
  : Mod extends "unique" ? { unique: true }
  : Mod extends "default(uuid)" ? { default: "uuid" }
  : Mod extends "default(autoincrement)" ? { default: "autoincrement" }
  : Mod extends `relation(${infer ForeignKeyField}.${infer ReferencedField})`
    ? {
      relation: {
        foreignKeyField: ForeignKeyField;
        referencedField: ReferencedField;
      };
    }
  : Mod extends "relation" ? { relation: true }
  : {};

type ParseEntry<E, S extends DbScopeSchema> = E extends string
  ? ParseFieldDefinition<E, S>["type"]
  : E extends object ? Resolve<
      {
        -readonly [K in keyof E]: ParseEntry<
          E[K],
          S
        >;
      } & ResolveRelationFields<E, S>
    >
  : never;

type ResolveRelationFields<
  E,
  S extends DbScopeSchema,
> = {
  [
    K in keyof E as E[K] extends string ? ParseFieldDefinition<
        E[K],
        S
      >["modifiers"] extends {
        relation: {
          foreignKeyField: infer ForeignKeyField extends string; // Add constraint here
        };
      } ? ForeignKeyField
      : never
      : never
  ]: string;
};

type ResolvedDbScope<S extends DbScopeSchema> = Resolve<
  {
    -readonly [K in keyof S]: ParseEntry<
      S[K],
      S
    >;
  }
>;

type PossibleFieldTypes<S> =
  | BaseTypeName
  | AliasName
  | keyof S
  | `${keyof S & string}[]`;

type PossibleModifiers =
  | "id"
  | "unique"
  | "default(uuid)"
  | "default(autoincrement)"
  | "relation"
  | `relation${string}`;

type PossibleFields<S, Model extends keyof S> = keyof S[Model];

type ValidateFieldDefinition<
  S,
  T extends string,
> = T extends `${infer Type}.${infer Modifiers}`
  ? `${ValidateType<S, Type>}${ValidateModifiers<
    S,
    Modifiers,
    Type
  >}`
  : ValidateType<S, T>;

type ValidateType<S, T extends string> = T extends PossibleFieldTypes<S> ? T
  : {
    [K in PossibleFieldTypes<S>]: K extends `${T}${string}` ? K
      : never;
  }[PossibleFieldTypes<S>] extends infer Suggestion
    ? Suggestion extends string ? Suggestion
    : `Invalid field type '${T}'. Did you mean one of: ${
      & PossibleFieldTypes<S>
      & string}`
  : never;

type ExtractModel<Type extends string> = Type extends `${infer Model}[]` ? Model
  : Type;

type ValidateModifiers<
  S,
  Mods extends string,
  Type extends string,
> = Mods extends "" ? ""
  : Mods extends `${infer Mod extends string}.${infer Rest extends string}` // Add constraints here
    ? `.${ValidateModifier<
      S,
      Mod,
      Type
    >}${ValidateModifiers<S, Rest, Type>}`
  : `.${ValidateModifier<S, Mods, Type>}`;

type ValidateModifier<
  S,
  Mod extends string,
  Type extends string,
> = Mod extends PossibleModifiers
  ? Mod extends `relation(${infer ForeignKeyField}.${infer ReferencedField})`
    ? ExtractModel<Type> extends infer Model
      ? Type extends `${string}[]` ? "relation"
      : Model extends keyof S
        ? ForeignKeyField extends string
          ? ReferencedField extends PossibleFields<S, Model> ? Mod
          : `Invalid referenced field '${ReferencedField}' in model. Did you mean one of: ${
            & PossibleFields<
              S,
              Model
            >
            & string}`
        : `Invalid foreign key field '${ForeignKeyField}'`
      : `Invalid model in relation`
    : never
  : Mod
  : {
    [K in PossibleModifiers]: K extends `${Mod}${string}` ? K
      : never;
  }[PossibleModifiers] extends infer Suggestion
    ? Suggestion extends string ? Suggestion
    : `Invalid modifier. Did you mean one of: ${
      & PossibleModifiers
      & string}`
  : never;

type ValidatedDbScopeSchema<S> = {
  [K in keyof S]: {
    [F in keyof S[K]]: S[K][F] extends string
      ? ValidateFieldDefinition<S, S[K][F]>
      : S[K][F] extends object ? ValidatedDbScopeSchema<S[K][F]>
      : never;
  };
};

function schema<const S extends DbScopeSchema>(
  schema: ValidatedDbScopeSchema<S>,
): ResolvedDbScope<S> {
  return schema as any;
}

const db = schema({
  user: {
    id: "string.id",
    name: "string",
    email: "string.unique",
    tags: "tag[]",
  },
  book: {
    id: "string.id",
    title: "string",
    tags: "tag[]",
  },
  tag: {
    id: "string.id",
    name: "string",
  },
});

type User = typeof db.user;
type Book = typeof db.book;
type Tag = typeof db.tag;

================
File: src/columns/base-columns.ts
================
import { Column, DataType } from "./column";
import { EnumValues } from "./properties";

class StringColumn extends Column<"string", string> {
  constructor() {
    super("string");
  }
}

class NumberColumn extends Column<"number", number> {
  constructor() {
    super("number");
  }
}

class BooleanColumn extends Column<"boolean", boolean> {
  constructor() {
    super("boolean");
  }
}

class DateColumn extends Column<"date", Date | number> {
  constructor() {
    super("date");
  }
}

class JsonColumn extends Column<"json", object | string> {
  constructor() {
    super("json");
  }
}

class JsonbColumn extends Column<"jsonb", object | string> {
  constructor() {
    super("jsonb");
  }
}

class UuidColumn extends Column<"uuid", string> {
  constructor() {
    super("uuid");
  }
}

class TextColumn extends Column<"text", string> {
  constructor() {
    super("text");
  }
}

class BigIntColumn extends Column<"bigint", bigint | number> {
  constructor() {
    super("bigint");
  }
}

class TimestampColumn extends Column<
  "timestamp",
  Date | string | number
> {
  private withTz: boolean;

  constructor(withTimezone: boolean = true) {
    super("timestamp");
    this.withTz = withTimezone;
  }

  withoutTimezone(): TimestampColumn {
    return new TimestampColumn(false);
  }

  get withTimezone(): boolean {
    return this.withTz;
  }
}

class TimeColumn extends Column<"time", string | Date> {
  private withTz: boolean;

  constructor(withTimezone: boolean = false) {
    super("time");
    this.withTz = withTimezone;
  }

  withTimezone(): TimeColumn {
    return new TimeColumn(true);
  }
}

class BinaryColumn extends Column<
  "binary",
  Uint8Array | Buffer | string
> {
  constructor() {
    super("binary");
  }
}

class DecimalColumn extends Column<"decimal", string | number> {
  constructor() {
    super("decimal");
  }
}

const LiteralValue = Symbol.for("Yatra/LiteralValue");
class LiteralColumn<
  T extends string | number | boolean,
> extends Column<"literal", T> {
  readonly [LiteralValue]: T;

  constructor(value: T) {
    super("literal");
    this[LiteralValue] = value;
  }
}

const ArrayItemType = Symbol.for("Yatra/ItemType");
class ArrayColumn<
  ItemType extends Column<any, any>,
> extends Column<
  "array",
  Array<ItemType[typeof DataType]>
> {
  readonly [ArrayItemType]: ItemType;

  constructor(itemType: ItemType) {
    super("array");
    this[ArrayItemType] = itemType;
  }
}

class EnumColumn<T extends string[]> extends Column<"enum", T[number]> {
  readonly [EnumValues]: T;

  constructor(values: T) {
    super("enum");
    this[EnumValues] = values;
  }
}

export function string(): StringColumn {
  return new StringColumn();
}

export function number(): NumberColumn {
  return new NumberColumn();
}

export function boolean(): BooleanColumn {
  return new BooleanColumn();
}

export function date(): DateColumn {
  return new DateColumn();
}

export function json(): JsonColumn {
  return new JsonColumn();
}

export function jsonb(): JsonbColumn {
  return new JsonbColumn();
}

export function uuid(): UuidColumn {
  return new UuidColumn();
}

export function text(): TextColumn {
  return new TextColumn();
}

export function bigint(): BigIntColumn {
  return new BigIntColumn();
}

export function timestamp(
  withTimezone: boolean = true,
): TimestampColumn {
  return new TimestampColumn(withTimezone);
}

export function time(
  withTimezone: boolean = false,
): TimeColumn {
  return new TimeColumn(withTimezone);
}

export function binary(): BinaryColumn {
  return new BinaryColumn();
}

export function decimal(): DecimalColumn {
  return new DecimalColumn();
}

export function literal<
  T extends string | number | boolean,
>(
  value: T,
): LiteralColumn<T> {
  return new LiteralColumn<T>(value);
}

export function array<T extends Column<any, any>>(
  itemType: T,
): ArrayColumn<T> {
  return new ArrayColumn<T>(itemType);
}

export function enum_<T extends string[]>(
  values: T,
): EnumColumn<T> {
  return new EnumColumn<T>(values);
}

================
File: src/columns/column.ts
================
import { Pipeable } from "effect";

export const Type = Symbol.for("Yatra/Column/Type");
export const DataType = Symbol.for("Yatra/Column/DataType");

export class Column<
  CT extends ColumnType,
  DT extends any,
> implements Pipeable.Pipeable {
  readonly [Type]: CT;
  declare readonly [DataType]: DT;

  constructor(type: CT) {
    this[Type] = type;
    this[DataType] = null as any;
  }

  pipe(..._: Array<Function>) {
    return Pipeable.pipeArguments(
      this,
      arguments,
    );
  }
}

export type ColumnType =
  | "string"
  | "number"
  | "boolean"
  | "date"
  | "literal"
  | "json"
  | "jsonb"
  | "uuid"
  | "array"
  | "binary"
  | "text"
  | "bigint"
  | "timestamp"
  | "time"
  | "inet"
  | "cidr"
  | "macaddr"
  | "decimal"
  | "enum";

export type GetDataType<T> = T extends Column<any, infer DataType> ? DataType
  : never;

================
File: src/columns/properties.ts
================
import type { Column, DataType } from "./column";
import { extend } from "./utils";

export type ColumnPropertyName = string | symbol;

export const ColumnName = Symbol.for("Yatra/ColumnName");
export type ColumnName<T extends string> = { readonly [ColumnName]: T };
export const columnName =
  <Col extends Column<any, any>, const ColName extends string>(name: ColName) =>
  (c: Col) => extend<Col, ColumnName<ColName>>(c, ColumnName, name);

export const Nullable = Symbol.for("Yatra/Nullable");
export type Nullable = { readonly [Nullable]: true };
export type IsNullable<T> = T extends Nullable ? true : false;
export const nullable = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, Nullable>(c, Nullable, true);

export const Unique = Symbol.for("Yatra/Unique");
export type Unique = { readonly [Unique]: true };
export type IsUnique<T> = T extends Unique ? true : false;
export const unique = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, Unique>(c, Unique, true);

export const PrimaryKey = Symbol.for("Yatra/PrimaryKey");
export type PrimaryKey = { readonly [PrimaryKey]: true };
export type IsPrimaryKey<T> = T extends PrimaryKey ? true : false;
export const primaryKey = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, PrimaryKey>(c, PrimaryKey, true);

export const Default = Symbol.for("Yatra/Default");
export type Default<T> = { readonly [Default]: T };
export type GetDefault<T> = T extends Default<infer V> ? V : undefined;
export const defaultValue =
  <Col extends Column<any, any>, const V extends Col[typeof DataType]>(
    value: V,
  ) =>
  (c: Col) => extend<Col, Default<V>>(c, Default, value);

export const MinLength = Symbol.for("Yatra/MinLength");
export type MinLength<T extends number> = { readonly [MinLength]: T };
export type GetMinLength<T> = T extends MinLength<infer V> ? V : undefined;
export const minLength =
  <Col extends Column<"string" | "text", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) => extend<Col, MinLength<T>>(c, MinLength, value);

export const MaxLength = Symbol.for("Yatra/MaxLength");
export type MaxLength<T extends number> = { readonly [MaxLength]: T };
export type GetMaxLength<T> = T extends MaxLength<infer V> ? V : undefined;
export const maxLength =
  <Col extends Column<"string" | "text", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) => extend<Col, MaxLength<T>>(c, MaxLength, value);

export const Format = Symbol.for("Yatra/Format");
export type Format<T extends string> = { readonly [Format]: T };
export const format =
  <Col extends Column<any, any>, const Fmt extends string>(fmt: Fmt) =>
  (c: Col) => extend<Col, Format<Fmt>>(c, Format, fmt);

export const Enum = Symbol.for("Yatra/Enum");
export type Enum<T extends unknown[]> = { readonly [Enum]: T };

export const Min = Symbol.for("Yatra/Min");
export type Min<T extends number> = { readonly [Min]: T };
export const min =
  <Col extends Column<"number", any>, const M extends number>(minValue: M) =>
  (c: Col) => extend<Col, Min<M>>(c, Min, minValue);

export const Max = Symbol.for("Yatra/Max");
export type Max<T extends number> = { readonly [Max]: T };
export const max =
  <Col extends Column<"number", any>, const M extends number>(maxValue: M) =>
  (c: Col) => extend<Col, Max<M>>(c, Max, maxValue);

export const Integer = Symbol.for("Yatra/Integer");
export type Integer = { readonly [Integer]: true };
export const integer = <Col extends Column<"number", any>>(c: Col) =>
  extend<Col, Integer>(c, Integer, true);

export const References = Symbol.for("Yatra/References");
export type References<T extends string> = {
  readonly [References]: { table: T; column: string };
};
export type GetReferences<T> = T extends References<infer Table>
  ? { table: Table; column: string }
  : undefined;
export const references =
  <Col extends Column<any, any>, const T extends string>(
    table: T,
    column: string,
  ) =>
  (c: Col) => extend<Col, References<T>>(c, References, { table, column });

export const AutoIncrement = Symbol.for("Yatra/AutoIncrement");
export type AutoIncrement = { readonly [AutoIncrement]: true };
export type IsAutoIncrement<T> = T extends AutoIncrement ? true : false;
export const autoIncrement = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, AutoIncrement>(c, AutoIncrement, true);

export const Generated = Symbol.for("Yatra/Generated");
export type Generated<T extends string> = {
  readonly [Generated]: { expression: T };
};
export type GetGenerated<T> = T extends Generated<infer Expr> ? Expr
  : undefined;
export const generated =
  <Col extends Column<any, any>, const T extends string>(expression: T) =>
  (c: Col) => extend<Col, Generated<T>>(c, Generated, { expression });

export const Comment = Symbol.for("Yatra/Comment");
export type Comment<T extends string> = { readonly [Comment]: T };
export type GetComment<T> = T extends Comment<infer Text> ? Text : undefined;
export const comment =
  <Col extends Column<any, any>, const T extends string>(text: T) => (c: Col) =>
    extend<Col, Comment<T>>(c, Comment, text);

export const Precision = Symbol.for("Yatra/Precision");
export type Precision<T extends number> = { readonly [Precision]: T };
export type GetPrecision<T> = T extends Precision<infer P> ? P : undefined;
export const precision =
  <Col extends Column<"number" | "decimal", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) => extend<Col, Precision<T>>(c, Precision, value);

export const Scale = Symbol.for("Yatra/Scale");
export type Scale<T extends number> = { readonly [Scale]: T };
export type GetScale<T> = T extends Scale<infer S> ? S : undefined;
export const scale =
  <Col extends Column<"number" | "decimal", any>, const T extends number>(
    value: T,
  ) =>
  (c: Col) => extend<Col, Scale<T>>(c, Scale, value);

export const Check = Symbol.for("Yatra/Check");
export type Check<T extends string> = { readonly [Check]: T };
export const check =
  <Col extends Column<any, any>, const T extends string>(expression: T) =>
  (c: Col) => extend<Col, Check<T>>(c, Check, expression);

export const Index = Symbol.for("Yatra/Index");
export type Index = { readonly [Index]: true };
export const index = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, Index>(c, Index, true);

export const SearchIndexed = Symbol.for("Yatra/SearchIndexed");
export type SearchIndexed = { readonly [SearchIndexed]: true };
export const searchIndexed = <Col extends Column<any, any>>(c: Col) =>
  extend<Col, SearchIndexed>(c, SearchIndexed, true);

export const LiteralValue = Symbol.for("Yatra/LiteralValue");
export const ItemType = Symbol.for("Yatra/ItemType");
export const EnumValues = Symbol.for("Yatra/EnumValues");

================
File: src/columns/utils.ts
================
import type { ColumnPropertyName } from "./properties";

export function extend<This, Brand>(
  instance: This,
  propertyName: ColumnPropertyName,
  propertyValue: unknown,
): This & Brand {
  const newInstance = Object.create(
    Object.getPrototypeOf(instance),
  );

  Object.assign(newInstance, instance);
  (newInstance as any)[propertyName] = propertyValue;

  return newInstance as This & Brand;
}

================
File: src/index.ts
================
import { date, number, string, uuid } from "./columns/base-columns";
import { defaultValue, nullable, primaryKey } from "./columns/properties";
import { pipe } from "./pipe";
import {
  type ExtractFields,
  manyToMany,
  manyToOne,
  oneToMany,
  oneToOne,
} from "./relations";
import { Table } from "./table";
import { construct } from "./utils";

const basicColumns = {
  id: pipe(uuid(), primaryKey),
  name: pipe(string()),
  createdAt: pipe(date(), defaultValue(new Date())),
  updatedAt: pipe(date(), defaultValue(new Date())),
};

class Book extends Table(
  "book",
  {
    ...basicColumns,
    authorId: string(),
    description: pipe(string(), defaultValue("what"), nullable),
    price: pipe(number(), nullable),
  },
) {}

class Author extends Table(
  "author",
  {
    ...basicColumns,
  },
) {}

type BookFields = ExtractFields<typeof Book>;

class AuthorProfile extends Table(
  "author_profile",
  {
    ...basicColumns,
  },
) {}

const authorToProfile = oneToOne(
  () => Author,
  () => AuthorProfile,
  "id",
);

const authorToBooks = oneToMany(
  () => Author,
  () => Book,
  "authorId",
);

const bookToAuthor = manyToOne(
  () => Book,
  () => Author,
  "authorId",
);

const bookToAuthors = manyToMany(
  () => Book,
  () => Author,
  "book_to_author",
  "id",
  "id",
);

const lol = bookToAuthor;

const source = lol.sourceTable;

================
File: src/pipe.ts
================
export function pipe<A>(a: A): A;
export function pipe<A, B = never>(
  a: A,
  ab: (a: A) => B,
): B;
export function pipe<A, B = never, C = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
): C;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
): D;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
): E;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
): F;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
): G;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
): H;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
): I;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
): J;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
): K;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
): L;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
): M;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
): N;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
): O;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
): P;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
): Q;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
): R;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
  S = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
  rs: (r: R) => S,
): S;
export function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
  S = never,
  T = never,
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
  rs: (r: R) => S,
  st: (s: S) => T,
): T;
export function pipe(
  a: unknown,
  ab?: Function,
  bc?: Function,
  cd?: Function,
  de?: Function,
  ef?: Function,
  fg?: Function,
  gh?: Function,
  hi?: Function,
): unknown {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab!(a);
    case 3:
      return bc!(ab!(a));
    case 4:
      return cd!(bc!(ab!(a)));
    case 5:
      return de!(cd!(bc!(ab!(a))));
    case 6:
      return ef!(de!(cd!(bc!(ab!(a)))));
    case 7:
      return fg!(ef!(de!(cd!(bc!(ab!(a))))));
    case 8:
      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))));
    case 9:
      return hi!(
        gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))),
      );
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

================
File: src/pipeable.ts
================
// https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Pipeable.ts

/**
 * @since 2.0.0
 */

/**
 * @since 2.0.0
 * @category models
 */
export interface Pipeable {
  pipe<A>(this: A): A;
  pipe<A, B = never>(this: A, ab: (_: A) => B): B;
  pipe<A, B = never, C = never>(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
  ): C;
  pipe<A, B = never, C = never, D = never>(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
  ): D;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
  ): E;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
  ): F;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
  ): G;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
  ): H;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
  ): I;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
  ): J;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
  ): K;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
  ): L;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
  ): M;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
  ): N;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
  ): O;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
  ): P;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
  ): Q;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
  ): R;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
  ): S;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
    T = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
    st: (_: S) => T,
  ): T;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
    T = never,
    U = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
    st: (_: S) => T,
    tu: (_: T) => U,
  ): U;
  pipe<
    A,
    B = never,
    C = never,
    D = never,
    E = never,
    F = never,
    G = never,
    H = never,
    I = never,
    J = never,
    K = never,
    L = never,
    M = never,
    N = never,
    O = never,
    P = never,
    Q = never,
    R = never,
    S = never,
    T = never,
    U = never,
  >(
    this: A,
    ab: (_: A) => B,
    bc: (_: B) => C,
    cd: (_: C) => D,
    de: (_: D) => E,
    ef: (_: E) => F,
    fg: (_: F) => G,
    gh: (_: G) => H,
    hi: (_: H) => I,
    ij: (_: I) => J,
    jk: (_: J) => K,
    kl: (_: K) => L,
    lm: (_: L) => M,
    mn: (_: M) => N,
    no: (_: N) => O,
    op: (_: O) => P,
    pq: (_: P) => Q,
    qr: (_: Q) => R,
    rs: (_: R) => S,
    st: (_: S) => T,
    tu: (_: T) => U,
  ): U;
}

/**
 * @since 2.0.0
 */
export const pipeArguments = <A>(
  self: A,
  args: IArguments,
): unknown => {
  switch (args.length) {
    case 0:
      return self;
    case 1:
      return args[0](self);
    case 2:
      return args[1](args[0](self));
    case 3:
      return args[2](args[1](args[0](self)));
    case 4:
      return args[3](
        args[2](args[1](args[0](self))),
      );
    case 5:
      return args[4](
        args[3](args[2](args[1](args[0](self)))),
      );
    case 6:
      return args[5](
        args[4](
          args[3](
            args[2](args[1](args[0](self))),
          ),
        ),
      );
    case 7:
      return args[6](
        args[5](
          args[4](
            args[3](
              args[2](args[1](args[0](self))),
            ),
          ),
        ),
      );
    case 8:
      return args[7](
        args[6](
          args[5](
            args[4](
              args[3](
                args[2](args[1](args[0](self))),
              ),
            ),
          ),
        ),
      );
    case 9:
      return args[8](
        args[7](
          args[6](
            args[5](
              args[4](
                args[3](
                  args[2](args[1](args[0](self))),
                ),
              ),
            ),
          ),
        ),
      );
    default: {
      let ret = self;
      for (
        let i = 0, len = args.length;
        i < len;
        i++
      ) {
        ret = args[i](ret);
      }
      return ret;
    }
  }
};

================
File: src/relations.ts
================
import { Pipeable } from "effect";
import type { TableType } from "./types";
import type { FieldsRecord, TableInstance } from "./types";

export const SourceTable = Symbol.for("Yatra/Relation/SourceTable");
export const DestinationTable = Symbol.for("Yatra/Relation/DestinationTable");
export const TableFields = Symbol.for("Yatra/Table/Fields");

type RelationTableConstructor = new(
  args: any,
) => TableInstance<string, FieldsRecord>;

export type ExtractFields<T> = T extends TableType<any, infer F> ? F
  : never;

export type ExtractKeys<T> = keyof ExtractFields<T>;
export type ExtractTableName<T> = T extends TableType<infer N, any> ? N : never;

export class Relation<
  S extends RelationTableConstructor | any,
  D extends RelationTableConstructor | any,
> implements Pipeable.Pipeable {
  public [SourceTable]: S;
  public [DestinationTable]: D;

  constructor(
    source: () => S,
    destination: () => D,
  ) {
    this[SourceTable] = source();
    this[DestinationTable] = destination();
  }

  pipe(..._: Array<Function>) {
    return Pipeable.pipeArguments(
      this,
      arguments,
    );
  }

  get sourceTable() {
    return this[SourceTable];
  }

  get destinationTable() {
    return this[DestinationTable];
  }
}

export class OneToOneRelation<
  S extends RelationTableConstructor | any,
  D extends RelationTableConstructor | any,
  FK extends ExtractKeys<S> = ExtractKeys<S>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public foreignKey: FK,
  ) {
    super(source, destination);
  }
}

export function oneToOne<
  S extends RelationTableConstructor | any,
  D extends RelationTableConstructor | any,
  FK extends ExtractKeys<S>,
>(
  source: () => S,
  destination: () => D,
  foreignKey: FK,
) {
  return new OneToOneRelation(source, destination, foreignKey);
}

export class OneToManyRelation<
  S extends RelationTableConstructor | any,
  D extends RelationTableConstructor | any,
  FK extends ExtractKeys<D> = ExtractKeys<D>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public foreignKey: FK,
  ) {
    super(source, destination);
  }
}

export function oneToMany<
  S extends RelationTableConstructor | any,
  D extends RelationTableConstructor | any,
  FK extends ExtractKeys<D>,
>(
  source: () => S,
  destination: () => D,
  foreignKey: FK,
) {
  return new OneToManyRelation(source, destination, foreignKey);
}

export class ManyToOneRelation<
  S extends RelationTableConstructor | any,
  D extends RelationTableConstructor | any,
  FK extends ExtractKeys<S> = ExtractKeys<S>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public foreignKey: FK,
  ) {
    super(source, destination);
  }
}

export function manyToOne<
  S extends RelationTableConstructor | any,
  D extends RelationTableConstructor | any,
  FK extends ExtractKeys<S>,
>(
  source: () => S,
  destination: () => D,
  foreignKey: FK,
) {
  return new ManyToOneRelation(source, destination, foreignKey);
}

export class ManyToManyRelation<
  S extends RelationTableConstructor | any,
  D extends RelationTableConstructor | any,
  JT extends string = string,
  SK extends ExtractKeys<S> = ExtractKeys<S>,
  DK extends ExtractKeys<D> = ExtractKeys<D>,
> extends Relation<S, D> {
  constructor(
    source: () => S,
    destination: () => D,
    public joinTable: JT,
    public sourceKey: SK,
    public destinationKey: DK,
  ) {
    super(source, destination);
  }
}

export function manyToMany<
  S extends RelationTableConstructor | any,
  D extends RelationTableConstructor | any,
  JT extends string,
  SK extends ExtractKeys<S>,
  DK extends ExtractKeys<D>,
>(
  source: () => S,
  destination: () => D,
  joinTable: JT,
  sourceKey: SK,
  destinationKey: DK,
) {
  return new ManyToManyRelation(
    source,
    destination,
    joinTable,
    sourceKey,
    destinationKey,
  );
}

================
File: src/table.ts
================
import {
  type FieldsRecord,
  type MakeTableObject,
  TableFields,
  TableName,
  type TableType,
} from "./types";

export type GetTableFields<T> = T extends TableType<any, infer Fields> ? Fields
  : never;

export function Table<
  const TableName extends string,
  const Fields extends FieldsRecord,
>(
  tableName: TableName,
  fields: Fields,
): TableType<TableName, Fields> {
  class TableClass {
    public [TableName]: TableName = tableName;
    public [TableFields]: Fields = fields;

    constructor(
      args: MakeTableObject<Fields>,
    ) {
      if (typeof args === "object") {
        for (const key in args) {
          (this as any)[key] = (args as any)[key];
        }
      }
    }
  }
  return TableClass as TableType<
    TableName,
    Fields
  >;
}

================
File: src/types.ts
================
import type { Column } from "./columns/column";
import type { IsNullable } from "./columns/properties";
import type { Clean } from "./utils";

export type FieldsRecord = Record<
  string,
  Column<any, any>
>;

export type TableConstructor<F> = new(
  ...args: any[]
) => { fields: F };

export type InferColumn<C> = C extends Column<any, infer T>
  ? IsNullable<C> extends true ? T | null : T
  : never;

export type InferFields<CR extends Record<string, Column<any, any>>> = {
  [k in keyof CR]: InferColumn<CR[k]>;
};

export type NullableFields<
  Fields = FieldsRecord,
> = {
  -readonly [
    k in keyof Fields as IsNullable<
      Fields[k]
    > extends true ? k
      : never
  ]?: InferColumn<Fields[k]>;
};

export type NonNullableFields<Fields = FieldsRecord> = {
  -readonly [
    k in keyof Fields as IsNullable<
      Fields[k]
    > extends false ? k
      : never
  ]: InferColumn<Fields[k]>;
};

export type MakeTableObject<
  Fields = FieldsRecord,
  Nullable = NullableFields<Fields>,
  NonNullable = NonNullableFields<Fields>,
> = Clean<Nullable & NonNullable>;

export const TableName = Symbol.for("Yatra/Table/Name");
export const TableFields = Symbol.for("Yatra/Table/Fields");

export type TableInstance<
  TableName extends string,
  Fields extends FieldsRecord,
> = {
  [TableName]: TableName;
  [TableFields]: Fields;
} & MakeTableObject<Fields>;

export type TableType<
  TableName extends string,
  Fields extends FieldsRecord,
> = {
  new(
    args: MakeTableObject<Fields>,
  ): TableInstance<TableName, Fields>;
};

================
File: src/utils.ts
================
export type Clean<T> =
  & { [k in keyof T]: T[k] }
  & unknown;

export type Class<
  O extends Record<string, unknown>,
> = {
  new(): InstanceType<new() => O>;
};

export type Constructor<
  Args = any,
  ReturnType = any,
> = new(
  ...args: Args[]
) => ReturnType;

/**
 * A curried type-safe wrapper around Reflect.construct
 *
 * @param constructor - The constructor function to invoke
 * @returns A function that accepts constructor arguments and returns an instance
 */
export function construct<T extends new(...args: any[]) => any>(
  constructor: T,
) {
  return <A extends ConstructorParameters<T>>(
    ...args: A
  ): InstanceType<T> => {
    return Reflect.construct(constructor, args) as InstanceType<T>;
  };
}

================
File: .gitignore
================
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

================
File: bun.lock
================
{
  "lockfileVersion": 1,
  "workspaces": {
    "": {
      "name": "dbschema",
      "dependencies": {
        "effect": "^3.14.1",
      },
      "devDependencies": {
        "@types/bun": "latest",
      },
      "peerDependencies": {
        "typescript": "^5.8.2",
      },
    },
  },
  "packages": {
    "@standard-schema/spec": ["@standard-schema/spec@1.0.0", "", {}, "sha512-m2bOd0f2RT9k8QJx1JN85cZYyH1RqFBdlwtkSlf4tBDYLCiiZnv1fIIwacK6cqwXavOydf0NPToMQgpKq+dVlA=="],

    "@types/bun": ["@types/bun@1.2.4", "", { "dependencies": { "bun-types": "1.2.4" } }, "sha512-QtuV5OMR8/rdKJs213iwXDpfVvnskPXY/S0ZiFbsTjQZycuqPbMW8Gf/XhLfwE5njW8sxI2WjISURXPlHypMFA=="],

    "@types/node": ["@types/node@22.13.10", "", { "dependencies": { "undici-types": "~6.20.0" } }, "sha512-I6LPUvlRH+O6VRUqYOcMudhaIdUVWfsjnZavnsraHvpBwaEyMN29ry+0UVJhImYL16xsscu0aske3yA+uPOWfw=="],

    "@types/ws": ["@types/ws@8.5.14", "", { "dependencies": { "@types/node": "*" } }, "sha512-bd/YFLW+URhBzMXurx7lWByOu+xzU9+kb3RboOteXYDfW+tr+JZa99OyNmPINEGB/ahzKrEuc8rcv4gnpJmxTw=="],

    "bun-types": ["bun-types@1.2.4", "", { "dependencies": { "@types/node": "*", "@types/ws": "~8.5.10" } }, "sha512-nDPymR207ZZEoWD4AavvEaa/KZe/qlrbMSchqpQwovPZCKc7pwMoENjEtHgMKaAjJhy+x6vfqSBA1QU3bJgs0Q=="],

    "effect": ["effect@3.14.1", "", { "dependencies": { "@standard-schema/spec": "^1.0.0", "fast-check": "^3.23.1" } }, "sha512-YrE6KYUu8r+fF3/cvdM+SZRZRjarVGhfcJwQjP/YyMmF79fwE1Rf0nWqLZ9Xfw7a9njm5/wmrYP83RYt5WTTbQ=="],

    "fast-check": ["fast-check@3.23.2", "", { "dependencies": { "pure-rand": "^6.1.0" } }, "sha512-h5+1OzzfCC3Ef7VbtKdcv7zsstUQwUDlYpUTvjeUsJAssPgLn7QzbboPtL5ro04Mq0rPOsMzl7q5hIbRs2wD1A=="],

    "pure-rand": ["pure-rand@6.1.0", "", {}, "sha512-bVWawvoZoBYpp6yIoQtQXHZjmz35RSVHnUOTefl8Vcjr8snTPY1wnpSPMWekcFwbxI6gtmT7rSYPFvz71ldiOA=="],

    "typescript": ["typescript@5.8.2", "", { "bin": { "tsc": "bin/tsc", "tsserver": "bin/tsserver" } }, "sha512-aJn6wq13/afZp/jT9QZmwEjDqqvSGp1VT5GVg+f/t6/oVyrgXM6BY1h9BRh/O5p3PlUPAe+WuiEZOmb/49RqoQ=="],

    "undici-types": ["undici-types@6.20.0", "", {}, "sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg=="],
  }
}

================
File: dprint.json
================
{
  "typescript": {
    "lineWidth": 80
  },
  "json": {},
  "markdown": {},
  "excludes": [
    "**/node_modules",
    "**/*-lock.json"
  ],
  "plugins": [
    "https://plugins.dprint.dev/typescript-0.94.0.wasm",
    "https://plugins.dprint.dev/json-0.20.0.wasm",
    "https://plugins.dprint.dev/markdown-0.18.0.wasm"
  ]
}

================
File: package.json
================
{
  "name": "yatra",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5.8.2"
  },
  "scripts": {
    "typecheck": "bun tsc --noEmit --incremental",
    "typecheck-watch": "bun tsc --noEmit --incremental --watch"
  },
  "dependencies": {
    "effect": "^3.14.1"
  }
}

================
File: README.md
================
# yatra

A playground for exploring ideas for a new, type-safe ORM for typescript.
Currently designed only with Postgres in mind

================
File: tsconfig.json
================
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
