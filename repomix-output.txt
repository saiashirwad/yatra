This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-13T15:30:29.220Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
scratch/
  class-magic.ts
  hkt_dump.ts
  old.ts
src/
  columns.ts
  table.ts
  utils.ts
.gitignore
biome.json
bun.lock
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: scratch/class-magic.ts
================
type Class<O extends Record<string, unknown>> = {
	new (): InstanceType<new () => O>
}

type Constructor<Args = any, ReturnType = any> = new (
	...args: Args[]
) => ReturnType

function Dict<const O extends Record<string, unknown>>(obj: O) {
	return class {
		constructor() {
			Object.assign(this, obj)
		}
	} as Class<O>
}

function member<
	Co extends Constructor,
	Instance extends InstanceType<Co>,
	K extends keyof Instance,
>(c: Co, key: K): Instance[K] {
	return new c()[key]
}

type ValidKeys<D> = keyof {
	[K in keyof D as D[K] extends string ? K : never]: D[K]
}

function ref<
	Co extends Constructor,
	Instance extends InstanceType<Co>,
	K extends ValidKeys<Instance>,
>(c: () => Co, key: K) {}

const personName = ref(() => Person, "name")

export class Person extends Dict({
	name: "hi",
	wrote: () => Book,
}) {}

const haha = member(Person, "name")

export class Book extends Dict({
	name: "what",
	otherBooks: () => new Array<Book>(),
	ownedBy: member(Person, "name"),
}) {}

export class Something extends Dict({
	name: "something",
	age: 2,
	owner: () => Person,
}) {}

const asdf = member(Something, "owner")

const b = new Book()
console.log(b.name)

const ModelMap = {
	person: Person,
	book: Book,
	something: Something,
} as const

type ModelMap = typeof ModelMap

type ModelType = keyof ModelMap

type ModelDataType<T> = {
	[K in keyof T]: T[K] extends () => infer R
		? R extends new () => any
			? Partial<InstanceType<R>>
			: T[K]
		: T[K]
}

function model<T extends ModelType>(
	type: T,
	data?: Partial<InstanceType<ModelMap[T]>>,
): InstanceType<ModelMap[T]> {
	const instance = new ModelMap[type]() as InstanceType<ModelMap[T]>
	if (data) {
		Object.assign(instance, data)
	}
	return instance
}

function create<T extends ModelType>(
	type: T,
	data?: ModelDataType<InstanceType<ModelMap[T]>>,
): InstanceType<ModelMap[T]> {
	const instance = new ModelMap[type]() as InstanceType<ModelMap[T]>
	if (data) {
		const processedData = Object.entries(data).reduce(
			(acc, [key, value]) => {
				// @ts-ignore
				const propertyType = instance[key]
				if (
					typeof propertyType === "function" &&
					propertyType.prototype?.constructor
				) {
					// If it's a model reference, create an instance
					acc[key] = create(key as ModelType, value as any)
				} else {
					acc[key] = value
				}
				return acc
			},
			{} as any,
		)

		Object.assign(instance, processedData)
	}
	return instance
}

const what = create("something", {
	name: "something",
	age: 2,
	owner: {
		name: "hi",
	},
})

console.log(what.name)

function LazyDict<O extends Record<string, unknown>>(obj: O) {
	return class {
		constructor() {
			return new Proxy(this, {
				get(target, prop) {
					const value = obj[prop as string]
					if (typeof value === "function") {
						return value()
					}
					return value
				},
			})
		}
	} as unknown as Class<O>
}

export class LazyBook extends LazyDict({
	title: "whaaat",
	author: () => new Person(),
}) {}

const lb = new LazyBook()
console.log(lb.title)

type ValueType<T, K extends keyof T> = T[K] extends (
	...args: any
) => any
	? ReturnType<T[K]> extends Constructor
		? InstanceType<ReturnType<T[K]>>
		: ReturnType<T[K]>
	: T[K]

type ClassStructure<
	T extends Constructor,
	I = {
		-readonly [K in keyof InstanceType<T>]: ValueType<
			InstanceType<T>,
			K
		>
	},
> = I

type BookStructure = ClassStructure<typeof Book>

================
File: scratch/hkt_dump.ts
================
//interface HKT<URI, A> {}
//
//interface SchemaURI {
//  readonly _URI: unique symbol;
//}
//
//interface StringFieldURI extends SchemaURI {
//  readonly StringField: unique symbol;
//}
//
//interface NumberFieldURI extends SchemaURI {
//  readonly NumberField: unique symbol;
//}
//interface JsonFieldURI extends SchemaURI {
//  readonly JsonField: unique symbol;
//}
//interface RelationFieldURI extends SchemaURI {
//  readonly RelationField: unique symbol;
//}
//
//type Kind<
//  URI,
//  A,
//  Ctx extends Record<string, any> = {},
//> = URI extends StringFieldURI
//  ? StringFieldF<Ctx>
//  : URI extends NumberFieldURI
//    ? NumberFieldF<Ctx>
//    : URI extends JsonFieldURI
//      ? JsonFieldF<Ctx>
//      : URI extends RelationFieldURI
//        ? RelationFieldF<Ctx>
//        : FieldF<URI & SchemaURI, A, Ctx>;
//
//interface FieldF<
//  URI extends SchemaURI,
//  A,
//  Ctx extends Record<string, any> = {},
//> {
//  readonly _URI: URI["_URI"];
//  readonly _A: A;
//  readonly _Ctx: Ctx;
//
//  primaryKey(): Kind<URI, A, Ctx & { __primaryKey: true }>;
//  notNull(): Kind<URI, A, Ctx & { __notNull: true }>;
//  unique(): Kind<URI, A, Ctx & { __unique: true }>;
//  default<V extends A>(value: V): Kind<URI, A, Ctx & { __default: V }>;
//}
//
//interface StringFieldF<Ctx extends Record<string, any> = {}>
//  extends FieldF<StringFieldURI, string, Ctx> {
//  format<F extends string>(format: F): StringFieldF<Ctx & { __format: F }>;
//  minLength(length: number): StringFieldF<Ctx & { __minLength: number }>;
//  maxLength(length: number): StringFieldF<Ctx & { __maxLength: number }>;
//}
//
//interface NumberFieldF<Ctx extends Record<string, any> = {}>
//  extends FieldF<NumberFieldURI, number, Ctx> {
//  min(value: number): NumberFieldF<Ctx & { __min: number }>;
//  max(value: number): NumberFieldF<Ctx & { __max: number }>;
//  integer(): NumberFieldF<Ctx & { __integer: true }>;
//  autoIncrement(): NumberFieldF<Ctx & { __autoIncrement: true }>;
//}
//
//interface JsonFieldF<Ctx extends Record<string, any> = {}>
//  extends FieldF<JsonFieldURI, object, Ctx> {
//  _jsonSchema?: Record<string, any>;
//}
//
//interface RelationFieldF<Ctx extends Record<string, any> = {}>
//  extends FieldF<RelationFieldURI, any, Ctx> {
//  onDelete(
//    action: "cascade" | "restrict" | "set null" | "set default",
//  ): RelationFieldF<Ctx & { __onDelete: string }>;
//  onUpdate(
//    action: "cascade" | "restrict" | "set null" | "set default",
//  ): RelationFieldF<Ctx & { __onUpdate: string }>;
//}
//
//function createMethod<
//  URI extends SchemaURI,
//  A,
//  Ctx extends Record<string, any>,
//  PropName extends string,
//  PropValue,
//>(
//  self: FieldF<URI, A, Ctx>,
//  propName: PropName,
//  propValue: PropValue,
//): Kind<URI, A, Ctx & { [K in PropName]: PropValue }> {
//  return Object.create(
//    Object.getPrototypeOf(self),
//    Object.getOwnPropertyDescriptors({
//      ...self,
//      _Ctx: { ...self._Ctx, [propName]: propValue },
//    }),
//  ) as Kind<URI, A, Ctx & { [K in PropName]: PropValue }>;
//}
//
//function createBaseFieldMethods<URI extends SchemaURI, A>() {
//  return {
//    primaryKey<Ctx extends Record<string, any>>(this: FieldF<URI, A, Ctx>) {
//      return createMethod(this, "__primaryKey", true);
//    },
//    notNull<Ctx extends Record<string, any>>(this: FieldF<URI, A, Ctx>) {
//      return createMethod(this, "__notNull", true);
//    },
//    unique<Ctx extends Record<string, any>>(this: FieldF<URI, A, Ctx>) {
//      return createMethod(this, "__unique", true);
//    },
//    default<Ctx extends Record<string, any>, V extends A>(
//      this: FieldF<URI, A, Ctx>,
//      value: V,
//    ) {
//      return createMethod(this, "__default", value);
//    },
//  };
//}
//
//function stringField(): StringFieldF<{}> {
//  const base = createBaseFieldMethods<StringFieldURI, string>();
//  const methods = {
//    ...base,
//    format<Ctx extends Record<string, any>, F extends string>(
//      this: StringFieldF<Ctx>,
//      f: F,
//    ) {
//      return createMethod(this, "__format", f);
//    },
//    minLength<Ctx extends Record<string, any>>(
//      this: StringFieldF<Ctx>,
//      len: number,
//    ) {
//      return createMethod(this, "__minLength", len);
//    },
//    maxLength<Ctx extends Record<string, any>>(
//      this: StringFieldF<Ctx>,
//      len: number,
//    ) {
//      return createMethod(this, "__maxLength", len);
//    },
//  };
//
//  return Object.create(methods, {
//    _URI: { value: Symbol("StringField"), writable: false },
//    _A: { value: undefined, writable: false },
//    _Ctx: { value: {}, writable: true },
//  }) as StringFieldF<{}>;
//}
//
//function numberField(): NumberFieldF<{}> {
//  const base = createBaseFieldMethods<NumberFieldURI, number>();
//  const methods = {
//    ...base,
//    min<Ctx extends Record<string, any>>(this: NumberFieldF<Ctx>, val: number) {
//      return createMethod(this, "__min", val);
//    },
//    max<Ctx extends Record<string, any>>(this: NumberFieldF<Ctx>, val: number) {
//      return createMethod(this, "__max", val);
//    },
//    integer<Ctx extends Record<string, any>>(this: NumberFieldF<Ctx>) {
//      return createMethod(this, "__integer", true);
//    },
//    autoIncrement<Ctx extends Record<string, any>>(this: NumberFieldF<Ctx>) {
//      return createMethod(this, "__autoIncrement", true);
//    },
//  };
//
//  return Object.create(methods, {
//    _URI: { value: Symbol("NumberField"), writable: false },
//    _A: { value: undefined, writable: false },
//    _Ctx: { value: {}, writable: true },
//  }) as NumberFieldF<{}>;
//}
//
//type JsonSchemaBuilder = {
//  string(): StringFieldF<{}>;
//  number(): NumberFieldF<{}>;
//  json<S extends Record<string, any>>(
//    schemaBuilder: (j: JsonSchemaBuilder) => S,
//  ): JsonFieldF<{}>;
//};
//
//function createJsonSchemaBuilder(): JsonSchemaBuilder {
//  return {
//    string: stringField,
//    number: numberField,
//    json: jsonField,
//  };
//}
//
//function jsonField<Schema extends Record<string, any>>(
//  schemaBuilder?: (j: JsonSchemaBuilder) => Schema,
//): JsonFieldF<{}> {
//  const base = createBaseFieldMethods<JsonFieldURI, object>();
//  const methods = { ...base };
//
//  const field = Object.create(methods, {
//    _URI: { value: Symbol("JsonField"), writable: false },
//    _A: { value: undefined, writable: false },
//    _Ctx: { value: {}, writable: true },
//  }) as JsonFieldF<{}>;
//
//  if (schemaBuilder) {
//    const b = createJsonSchemaBuilder();
//    const schema = schemaBuilder(b);
//    Object.defineProperty(field, "_jsonSchema", {
//      value: schema,
//      writable: false,
//      enumerable: true,
//    });
//  }
//
//  return field;
//}
//
//function relationField<T extends string>(tableName: T, foreignKey?: string) {
//  const base = createBaseFieldMethods<RelationFieldURI, any>();
//  const methods = {
//    ...base,
//    onDelete<Ctx extends Record<string, any>>(
//      this: RelationFieldF<Ctx>,
//      action: "cascade" | "restrict" | "set null" | "set default",
//    ) {
//      return createMethod(this, "__onDelete", action);
//    },
//    onUpdate<Ctx extends Record<string, any>>(
//      this: RelationFieldF<Ctx>,
//      action: "cascade" | "restrict" | "set null" | "set default",
//    ) {
//      return createMethod(this, "__onUpdate", action);
//    },
//  };
//
//  return Object.create(methods, {
//    _URI: { value: Symbol("RelationField"), writable: false },
//    _A: { value: undefined, writable: false },
//    _Ctx: {
//      value: { __tableName: tableName, __foreignKey: foreignKey },
//      writable: true,
//    },
//  }) as RelationFieldF<{ __tableName: T; __foreignKey?: string }>;
//}
//
//type TableDefinition<T extends Record<string, FieldF<any, any, any>>> = {
//  __fields: T;
//};
//
//type AnyTableMap = Record<string, TableDefinition<any>>;
//
//type FinalSchema<Tables extends AnyTableMap> = {
//  __tables: Tables;
//  table<K extends keyof Tables>(name: K): Tables[K];
//} & {
//  [K in keyof Tables & string]: (
//    foreignKey?: string,
//  ) => RelationFieldF<{ __tableName: K; __foreignKey?: string }>;
//};
//
//interface SchemaBuilderWithTables<Tables extends AnyTableMap> {
//  string(): StringFieldF<{}>;
//  number(): NumberFieldF<{}>;
//  json<S extends Record<string, any>>(
//    fn: (j: JsonSchemaBuilder) => S,
//  ): JsonFieldF<{}>;
//
//  table<
//    Name extends string,
//    Fields extends Record<string, FieldF<any, any, any>>,
//  >(
//    name: Name,
//    fieldsOrBuilder: Fields | ((t: Record<string, string>) => Fields),
//  ): SchemaBuilderWithTables<Tables & { [K in Name]: TableDefinition<Fields> }>;
//
//  build(): FinalSchema<Tables>;
//}
//
//function makeSchemaBuilder(): SchemaBuilderWithTables<{}> {
//  return makeSchemaBuilderWithTables({});
//}
//
//function makeSchemaBuilderWithTables<Tables extends AnyTableMap>(
//  tables: Tables,
//): SchemaBuilderWithTables<Tables> {
//  return {
//    string: stringField,
//    number: numberField,
//    json: jsonField,
//
//    table<
//      Name extends string,
//      Fields extends Record<string, FieldF<any, any, any>>,
//    >(
//      name: Name,
//      fieldsOrBuilder: Fields | ((t: Record<string, string>) => Fields),
//    ) {
//      let fields: Fields;
//      if (typeof fieldsOrBuilder === "function") {
//        const tableHelper = new Proxy(
//          {},
//          {
//            get(_target, propKey) {
//              return typeof propKey === "string" ? propKey : undefined;
//            },
//          },
//        );
//        fields = fieldsOrBuilder(tableHelper as Record<string, string>);
//      } else {
//        fields = fieldsOrBuilder;
//      }
//
//      const next: Tables & { [K in Name]: TableDefinition<Fields> } = {
//        ...tables,
//        [name]: { __fields: fields },
//      };
//      return makeSchemaBuilderWithTables(next);
//    },
//
//    build(): FinalSchema<Tables> {
//      return new Proxy(
//        // @ts-ignore
//        {
//          __tables: tables,
//          table(name: keyof Tables) {
//            return tables[name];
//          },
//        },
//        {
//          get(target, prop: string) {
//            if (prop in tables) {
//              return (foreignKey?: string) => relationField(prop, foreignKey);
//            }
//            if (prop in target) {
//              return (target as any)[prop];
//            }
//            return undefined;
//          },
//        },
//      ) as FinalSchema<Tables>;
//    },
//  };
//}
//
//const db = makeSchemaBuilder()
//  .table("user", {
//    id: stringField().primaryKey().format("uuid"),
//    name: stringField(),
//    email: stringField().unique(),
//    createdAt: stringField().default("now()"),
//  })
//  .table("book", (t) => ({
//    id: stringField().primaryKey().format("uuid"),
//    title: stringField().notNull(),
//    authorId: stringField(),
//    author: relationField("user", t.authorId).onDelete("cascade"),
//    metadata: jsonField((j) => ({
//      publishedYear: j.number(),
//      publisher: j.string(),
//      tags: j.json((j2) => ({
//        name: j2.string(),
//      })),
//    })),
//  }))
//  .build();
//
//const userTable = db.table("user");
//const bookTable = db.table("book");
//
//const someRelation = db.book("foreignKeyHere");
//console.log(db);
//
//type ExtractContext<T> = T extends FieldF<any, any, infer Ctx> ? Ctx : never;
//
//type UserIdType = ExtractContext<typeof userTable.__fields.id>;
//
//type BookAuthorType = ExtractContext<typeof bookTable.__fields.author>;

================
File: scratch/old.ts
================
//type Clean<T> = { [k in keyof T]: T[k] } & unknown
//type Trim<T> = {
//	[k in keyof T as T[k] extends undefined ? never : k]: T[k]
//}
//
//function updateOptions<
//	T extends {
//		options: Record<string, unknown>
//	},
//	KV extends { [k: string]: unknown },
//>(r: T, kv: KV): Clean<T & { options: KV }> {
//	return {
//		...r,
//		options: { ...r.options, ...kv },
//	}
//}
//
//type BaseColumnOptions<Type extends string, T> = {
//	type: Type
//	__nullable?: boolean
//	__default?: T
//}
//
//interface Column<
//	Type extends string,
//	T,
//	options extends BaseColumnOptions<Type, T> = {
//		type: Type
//	},
//> {
//	options: BaseColumnOptions<Type, T>
//	nullable: () => Column<
//		Type,
//		T,
//		Clean<options & { __nullable: true }>
//	>
//	default: <V extends T>(
//		value: V,
//	) => Column<Type, T, Clean<options & { __default: V }>>
//}
//
//function Column<
//	const Type extends string,
//	T = unknown,
//	options extends BaseColumnOptions<Type, T> = {
//		type: Type
//	},
//>(
//	type: Type,
//	defaultOptions?: options,
//): Column<Type, T, options> {
//	const options = {
//		type,
//		...(defaultOptions ?? {}),
//	}
//	return {
//		options,
//		nullable() {
//			return updateOptions(this, {
//				__nullable: true,
//			})
//		},
//		default<U extends T>(value: U) {
//			return updateOptions(this, {
//				__default: value,
//			})
//		},
//	}
//}
//
//type StringFormat = "uuid" | "json"
//
//type StringColumnOptions = BaseColumnOptions<
//	"string",
//	string
//> & {
//	__minLength?: number
//	__maxLength?: number
//	__format?: StringFormat
//	__enum?: unknown[]
//}
//
//type StringColumn<
//	options extends StringColumnOptions = {
//		type: "string"
//	},
//> = Column<"string", string, options> & {
//	minLength: <T extends number>(
//		length: T,
//	) => StringColumn<Clean<options & { __minLength: T }>>
//	maxLength: <T extends number>(
//		length: T,
//	) => StringColumn<Clean<options & { __maxLength: T }>>
//	format: <T extends StringFormat>(
//		format: T,
//	) => StringColumn<Clean<options & { __format: T }>>
//	enum: <T extends unknown[]>(
//		values: T,
//	) => StringColumn<Clean<options & { __enum: T }>>
//}
//
//function string(): StringColumn {
//	return {
//		...Column<"string", string>("string"),
//		minLength(value) {
//			return updateOptions(this, {
//				__minLength: value,
//			})
//		},
//		maxLength(value) {
//			return updateOptions(this, {
//				__maxLength: value,
//			})
//		},
//		format(format) {
//			return updateOptions(this, {
//				__format: format,
//			})
//		},
//		enum(values) {
//			return updateOptions(this, {
//				__enum: values,
//			})
//		},
//	}
//}
//
//type LiteralType = string | number | boolean
//
//type LiteralColumn<T extends LiteralType> = Column<
//	"literal",
//	T
//>
//
//function literal<const T extends LiteralType>(
//	value: T,
//): LiteralColumn<T> {
//	const base = Column<
//		`literal`,
//		T,
//		{ type: "literal"; __literalValue: T }
//	>("literal", {
//		type: "literal",
//		__literalValue: value,
//	})
//	return {
//		...base,
//		options: {
//			...base.options,
//		},
//	}
//}
//
//type NumberColumnOptions = BaseColumnOptions<
//	"number",
//	number
//> & {
//	__min?: number
//	__max?: number
//	__integer?: boolean
//}
//
//type NumberColumn<
//	options extends NumberColumnOptions = {
//		type: "number"
//	},
//> = Column<"number", number, options> & {
//	min: <V extends number>(
//		value: V,
//	) => NumberColumn<Clean<options & { __min: V }>>
//	max: <V extends number>(
//		value: V,
//	) => NumberColumn<Clean<options & { __max: V }>>
//	integer: () => NumberColumn<
//		Clean<options & { __integer: true }>
//	>
//}
//
//function number(): NumberColumn {
//	const base = Column<"number", number>("number")
//
//	return {
//		...base,
//		min(value) {
//			return updateOptions(this, {
//				__min: value,
//			})
//		},
//		max(value) {
//			return updateOptions(this, {
//				__max: value,
//			})
//		},
//		integer() {
//			return updateOptions(this, {
//				__integer: true,
//			})
//		},
//	}
//}
//
//const uuidField = string()
//	.format("uuid")
//	.nullable()
//	.default("something")
//console.log(uuidField.options)
//
//const something = literal("hi")
//console.log(something.options.type)
//
//const username = string().minLength(3).maxLength(20)
//console.log(username.options)
//
//const age = number().min(0).max(120).integer()
//console.log(age.options)
//
//const price = number().max(2).min(-2)
//console.log(price.options)
//
//const enumTest = string().enum(["admin", "user", "guest"])
//console.log(enumTest.options)

================
File: src/columns.ts
================
import type { Clean } from "./utils"

function updateOptions<
	T extends { options: Record<string, unknown> },
	KV extends { [k: string]: unknown },
>(r: T, kv: KV): Clean<T & { options: KV }> {
	return {
		...r,
		options: { ...r.options, ...kv },
	}
}

export type BaseColumnOptions<FieldType extends string, DataType> = {
	name: FieldType
	__nullable?: boolean
	__default?: DataType
}

export interface BaseColumn<
	FieldType extends string,
	DataType,
	options extends BaseColumnOptions<FieldType, DataType> = {
		name: FieldType
	},
> {
	options: BaseColumnOptions<FieldType, DataType>
	nullable: () => BaseColumn<FieldType, DataType, Clean<options & { __nullable: true }>>
	default: <V extends DataType>(
		value: V,
	) => BaseColumn<FieldType, DataType, Clean<options & { __default: V }>>
}

export function BaseColumn<
	const FieldType extends string,
	DataType = unknown,
	Options extends BaseColumnOptions<FieldType, DataType> = {
		name: FieldType
	},
>(name: FieldType, defaultOptions?: Options): BaseColumn<FieldType, DataType, Options> {
	const options = {
		name,
		...(defaultOptions ?? {}),
	}
	return {
		options,
		nullable() {
			return updateOptions(this, {
				__nullable: true,
			})
		},
		default<U extends DataType>(value: U) {
			return updateOptions(this, {
				__default: value,
			})
		},
	}
}

type StringFormat = "uuid" | "json"

type StringColumnOptions = BaseColumnOptions<"string", string> & {
	__minLength?: number
	__maxLength?: number
	__format?: StringFormat
	__enum?: unknown[]
}

type StringColumn<
	Options extends StringColumnOptions = {
		name: "string"
	},
> = BaseColumn<"string", string, Options> & {
	minLength: <T extends number>(length: T) => StringColumn<Clean<Options & { __minLength: T }>>
	maxLength: <T extends number>(length: T) => StringColumn<Clean<Options & { __maxLength: T }>>
	format: <T extends StringFormat>(format: T) => StringColumn<Clean<Options & { __format: T }>>
	enum: <T extends unknown[]>(values: T) => StringColumn<Clean<Options & { __enum: T }>>
}

export function string(): StringColumn {
	return {
		...BaseColumn<"string", string>("string"),
		minLength(value) {
			return updateOptions(this, {
				__minLength: value,
			})
		},
		maxLength(value) {
			return updateOptions(this, {
				__maxLength: value,
			})
		},
		format(format) {
			return updateOptions(this, {
				__format: format,
			})
		},
		enum(values) {
			return updateOptions(this, {
				__enum: values,
			})
		},
	}
}

type LiteralFieldType = string | number | boolean

type LiteralColumn<DataType extends LiteralFieldType> = BaseColumn<"literal", DataType>

export function literal<const DataType extends LiteralFieldType>(
	value: DataType,
): LiteralColumn<DataType> {
	const base = BaseColumn<`literal`, DataType, { name: "literal"; __literalValue: DataType }>(
		"literal",
		{
			name: "literal",
			__literalValue: value,
		},
	)
	return {
		...base,
		options: {
			...base.options,
		},
	}
}

type NumberColumnOptions = BaseColumnOptions<"number", number> & {
	__min?: number
	__max?: number
	__integer?: boolean
}

type NumberColumn<
	Options extends NumberColumnOptions = {
		name: "number"
	},
> = BaseColumn<"number", number, Options> & {
	min: <V extends number>(value: V) => NumberColumn<Clean<Options & { __min: V }>>
	max: <V extends number>(value: V) => NumberColumn<Clean<Options & { __max: V }>>
	integer: () => NumberColumn<Clean<Options & { __integer: true }>>
}

export function number(): NumberColumn {
	const base = BaseColumn<"number", number>("number")

	return {
		...base,
		min(value) {
			return updateOptions(this, {
				__min: value,
			})
		},
		max(value) {
			return updateOptions(this, {
				__max: value,
			})
		},
		integer() {
			return updateOptions(this, {
				__integer: true,
			})
		},
	}
}

type DateDataType = Date | number
type DateColumnOptions = BaseColumnOptions<"date", DateDataType> & {}

type DateColumn<
	Options extends DateColumnOptions = {
		name: "date"
	},
> = BaseColumn<"date", DateDataType, Options> & {}

export function date(): DateColumn {
	const base = BaseColumn<"date", DateDataType>("date")

	return {
		...base,
	}
}

================
File: src/table.ts
================
import { BaseColumn, string } from "./columns"
import { type Class, type Clean, type Constructor } from "./utils"

export function member<
	Co extends Constructor,
	Instance extends InstanceType<Co>,
	K extends keyof Instance,
>(c: Co, key: K): Instance[K] {
	return new c()[key]
}

type ManyToOne<VirtualField, Ref, foreignKey> = {
	kind: "many-to-one"
	virtualField: VirtualField
	ref: Ref
	foreignKey: foreignKey
}

function ManyToOne<
	Ref extends () => { fields: any },
	VirtualField extends string,
	FK extends keyof ReturnType<Ref>["fields"],
>(ref: Ref, virtualField: VirtualField, foreignKey: FK): ManyToOne<VirtualField, Ref, FK> {
	return {
		kind: "many-to-one",
		virtualField,
		ref,
		foreignKey,
	}
}

type OneToMany<Ref> = {
	kind: "one-to-many"
	ref: Ref
}

function OneToMany<Ref extends () => any>(ref: Ref): OneToMany<Ref> {
	return {
		kind: "one-to-many",
		ref,
	}
}

type Relation = ManyToOne<any, any, any> | OneToMany<any>

type TableConstructor<F, R> = {
	new (): { fields: F; relations: R }
	fields: F
	relations: R
}

function Table<
	const TableName extends string,
	const Fields extends Record<string, BaseColumn<any, any>>,
	const Relations extends Record<string, Relation>,
>(tableName: TableName, _fields: Fields, _relations: Relations = {} as Relations) {
	class TableClass {
		constructor(
			public name: TableName = tableName,
			public fields: Fields = _fields,
			public relations: Relations = _relations,
		) {}
	}

	return TableClass as unknown as TableConstructor<Fields, Relations>
}

class User extends Table(
	"user",
	{
		id: string(),
		name: string().maxLength(5).nullable(),
	},
	{
		books: OneToMany(() => Book),
	},
) {}

class Book extends Table(
	"book",
	{
		id: string(),
		authorId: string(),
	},
	{
		author: ManyToOne(() => User, "authorId", "id"),
	},
) {}

//const userId = member(User, "fields").id
//const bookRelations = member(Book, "relations")
//
//console.log(userId)
//console.log(bookRelations)

================
File: src/utils.ts
================
export type Clean<T> = { [k in keyof T]: T[k] } & unknown

export type Class<O extends Record<string, unknown>> = {
	new (): InstanceType<new () => O>
}

export type Constructor<Args = any, ReturnType = any> = new (
	...args: Args[]
) => ReturnType

export function member<
	Co extends Constructor,
	Instance extends InstanceType<Co>,
	K extends keyof Instance,
>(c: Co, key: K): Instance[K] {
	return new c()[key]
}

================
File: .gitignore
================
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

================
File: biome.json
================
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "files": {
    "ignoreUnknown": false,
    "ignore": []
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "tab"
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": false
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double",
      "lineWidth": 100,
      "semicolons": "asNeeded",
      "trailingCommas": "all"
    }
  }
}

================
File: bun.lock
================
{
  "lockfileVersion": 1,
  "workspaces": {
    "": {
      "name": "dbschema",
      "dependencies": {
        "arktype": "^2.1.9",
        "effect": "^3.13.10",
      },
      "devDependencies": {
        "@biomejs/biome": "^1.9.4",
        "@types/bun": "latest",
      },
      "peerDependencies": {
        "typescript": "^5",
      },
    },
  },
  "packages": {
    "@ark/schema": ["@ark/schema@0.44.4", "", { "dependencies": { "@ark/util": "0.44.4" } }, "sha512-TsZTX+k5J7xsGABsFjVdRUNgViGDMLv73sikBM8JNxC4STe0suTuMNa1OJ/AFP2N+LpJ1zL9tdWlg28PRqAYhg=="],

    "@ark/util": ["@ark/util@0.44.4", "", {}, "sha512-zLfNZrsq5Dq+8B0pHJwL/wD3xNBHb8FoP0FuPB455w7HpqVaqO5qPXvn+YoO8v1Y6pNwLVsM9vCIiO221LoODQ=="],

    "@biomejs/biome": ["@biomejs/biome@1.9.4", "", { "optionalDependencies": { "@biomejs/cli-darwin-arm64": "1.9.4", "@biomejs/cli-darwin-x64": "1.9.4", "@biomejs/cli-linux-arm64": "1.9.4", "@biomejs/cli-linux-arm64-musl": "1.9.4", "@biomejs/cli-linux-x64": "1.9.4", "@biomejs/cli-linux-x64-musl": "1.9.4", "@biomejs/cli-win32-arm64": "1.9.4", "@biomejs/cli-win32-x64": "1.9.4" }, "bin": { "biome": "bin/biome" } }, "sha512-1rkd7G70+o9KkTn5KLmDYXihGoTaIGO9PIIN2ZB7UJxFrWw04CZHPYiMRjYsaDvVV7hP1dYNRLxSANLaBFGpog=="],

    "@biomejs/cli-darwin-arm64": ["@biomejs/cli-darwin-arm64@1.9.4", "", { "os": "darwin", "cpu": "arm64" }, "sha512-bFBsPWrNvkdKrNCYeAp+xo2HecOGPAy9WyNyB/jKnnedgzl4W4Hb9ZMzYNbf8dMCGmUdSavlYHiR01QaYR58cw=="],

    "@biomejs/cli-darwin-x64": ["@biomejs/cli-darwin-x64@1.9.4", "", { "os": "darwin", "cpu": "x64" }, "sha512-ngYBh/+bEedqkSevPVhLP4QfVPCpb+4BBe2p7Xs32dBgs7rh9nY2AIYUL6BgLw1JVXV8GlpKmb/hNiuIxfPfZg=="],

    "@biomejs/cli-linux-arm64": ["@biomejs/cli-linux-arm64@1.9.4", "", { "os": "linux", "cpu": "arm64" }, "sha512-fJIW0+LYujdjUgJJuwesP4EjIBl/N/TcOX3IvIHJQNsAqvV2CHIogsmA94BPG6jZATS4Hi+xv4SkBBQSt1N4/g=="],

    "@biomejs/cli-linux-arm64-musl": ["@biomejs/cli-linux-arm64-musl@1.9.4", "", { "os": "linux", "cpu": "arm64" }, "sha512-v665Ct9WCRjGa8+kTr0CzApU0+XXtRgwmzIf1SeKSGAv+2scAlW6JR5PMFo6FzqqZ64Po79cKODKf3/AAmECqA=="],

    "@biomejs/cli-linux-x64": ["@biomejs/cli-linux-x64@1.9.4", "", { "os": "linux", "cpu": "x64" }, "sha512-lRCJv/Vi3Vlwmbd6K+oQ0KhLHMAysN8lXoCI7XeHlxaajk06u7G+UsFSO01NAs5iYuWKmVZjmiOzJ0OJmGsMwg=="],

    "@biomejs/cli-linux-x64-musl": ["@biomejs/cli-linux-x64-musl@1.9.4", "", { "os": "linux", "cpu": "x64" }, "sha512-gEhi/jSBhZ2m6wjV530Yy8+fNqG8PAinM3oV7CyO+6c3CEh16Eizm21uHVsyVBEB6RIM8JHIl6AGYCv6Q6Q9Tg=="],

    "@biomejs/cli-win32-arm64": ["@biomejs/cli-win32-arm64@1.9.4", "", { "os": "win32", "cpu": "arm64" }, "sha512-tlbhLk+WXZmgwoIKwHIHEBZUwxml7bRJgk0X2sPyNR3S93cdRq6XulAZRQJ17FYGGzWne0fgrXBKpl7l4M87Hg=="],

    "@biomejs/cli-win32-x64": ["@biomejs/cli-win32-x64@1.9.4", "", { "os": "win32", "cpu": "x64" }, "sha512-8Y5wMhVIPaWe6jw2H+KlEm4wP/f7EW3810ZLmDlrEEy5KvBsb9ECEfu/kMWD484ijfQ8+nIi0giMgu9g1UAuuA=="],

    "@standard-schema/spec": ["@standard-schema/spec@1.0.0", "", {}, "sha512-m2bOd0f2RT9k8QJx1JN85cZYyH1RqFBdlwtkSlf4tBDYLCiiZnv1fIIwacK6cqwXavOydf0NPToMQgpKq+dVlA=="],

    "@types/bun": ["@types/bun@1.2.4", "", { "dependencies": { "bun-types": "1.2.4" } }, "sha512-QtuV5OMR8/rdKJs213iwXDpfVvnskPXY/S0ZiFbsTjQZycuqPbMW8Gf/XhLfwE5njW8sxI2WjISURXPlHypMFA=="],

    "@types/node": ["@types/node@22.13.10", "", { "dependencies": { "undici-types": "~6.20.0" } }, "sha512-I6LPUvlRH+O6VRUqYOcMudhaIdUVWfsjnZavnsraHvpBwaEyMN29ry+0UVJhImYL16xsscu0aske3yA+uPOWfw=="],

    "@types/ws": ["@types/ws@8.5.14", "", { "dependencies": { "@types/node": "*" } }, "sha512-bd/YFLW+URhBzMXurx7lWByOu+xzU9+kb3RboOteXYDfW+tr+JZa99OyNmPINEGB/ahzKrEuc8rcv4gnpJmxTw=="],

    "arktype": ["arktype@2.1.9", "", { "dependencies": { "@ark/schema": "0.44.4", "@ark/util": "0.44.4" } }, "sha512-bq46shcLpfop4D9acVQN/+quZ+hIGs4OUzoLq2vCaZLdkITOlWkfamBk9abMuC6fbgxW1fu/2PamcQgggWhTwQ=="],

    "bun-types": ["bun-types@1.2.4", "", { "dependencies": { "@types/node": "*", "@types/ws": "~8.5.10" } }, "sha512-nDPymR207ZZEoWD4AavvEaa/KZe/qlrbMSchqpQwovPZCKc7pwMoENjEtHgMKaAjJhy+x6vfqSBA1QU3bJgs0Q=="],

    "effect": ["effect@3.13.10", "", { "dependencies": { "@standard-schema/spec": "^1.0.0", "fast-check": "^3.23.1" } }, "sha512-f2n51BJJ25G9rb/C1ClkgsVFXH6YTkCHmd6ebpu6cAkwQxfhnfbkVWKgkn3nyW9YnC9z4K8bGohRYaZ+HyWtLg=="],

    "fast-check": ["fast-check@3.23.2", "", { "dependencies": { "pure-rand": "^6.1.0" } }, "sha512-h5+1OzzfCC3Ef7VbtKdcv7zsstUQwUDlYpUTvjeUsJAssPgLn7QzbboPtL5ro04Mq0rPOsMzl7q5hIbRs2wD1A=="],

    "pure-rand": ["pure-rand@6.1.0", "", {}, "sha512-bVWawvoZoBYpp6yIoQtQXHZjmz35RSVHnUOTefl8Vcjr8snTPY1wnpSPMWekcFwbxI6gtmT7rSYPFvz71ldiOA=="],

    "typescript": ["typescript@5.8.2", "", { "bin": { "tsc": "bin/tsc", "tsserver": "bin/tsserver" } }, "sha512-aJn6wq13/afZp/jT9QZmwEjDqqvSGp1VT5GVg+f/t6/oVyrgXM6BY1h9BRh/O5p3PlUPAe+WuiEZOmb/49RqoQ=="],

    "undici-types": ["undici-types@6.20.0", "", {}, "sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg=="],
  }
}

================
File: package.json
================
{
	"name": "yatra",
	"module": "index.ts",
	"type": "module",
	"private": true,
	"devDependencies": {
		"@biomejs/biome": "^1.9.4",
		"@types/bun": "latest"
	},
	"peerDependencies": {
		"typescript": "^5"
	},
	"dependencies": {
		"arktype": "^2.1.9",
		"effect": "^3.13.10"
	}
}

================
File: README.md
================
# yatra

## goals

================
File: tsconfig.json
================
{
	"compilerOptions": {
		// Enable latest features
		"lib": ["ESNext", "DOM"],
		"target": "ESNext",
		"module": "ESNext",
		"moduleDetection": "force",
		"jsx": "react-jsx",
		"allowJs": true,

		// Bundler mode
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"verbatimModuleSyntax": true,
		"noEmit": true,

		// Best practices
		"strict": true,
		"skipLibCheck": true,
		"noFallthroughCasesInSwitch": true,

		// Some stricter flags (disabled by default)
		"noUnusedLocals": false,
		"noUnusedParameters": false,
		"noPropertyAccessFromIndexSignature": false
	}
}
